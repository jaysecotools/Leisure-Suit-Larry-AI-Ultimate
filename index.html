<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leisure Suit Larry: Enhanced Multi-NPC Adventures</title>
    <style>
/* ===== CSS RESET & BASE ===== */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Roboto, sans-serif;
    -webkit-tap-highlight-color: transparent;
}

:root {
    --primary: #9b59b6;
    --primary-dark: #8e44ad;
    --secondary: #3498db;
    --success: #2ecc71;
    --success-dark: #27ae60;
    --danger: #e74c3c;
    --danger-dark: #c0392b;
    --warning: #f1c40f;
    --warning-dark: #f39c12;
    --dark: #2c3e50;
    --darker: #1a252f;
    --light: #ecf0f1;
    --surface: #34495e;
    --surface-light: #4a6583;
    --surface-dark: #2c3e50;
    --text: #ffffff;
    --text-secondary: #bdc3c7;
    --adult: #e84393;
    --adult-light: #fd79a8;
    --adult-dark: #c44569;
    --overlay: rgba(0, 0, 0, 0.85);
    
    /* NPC Colors */
    --eve: #e74c3c;
    --jessica: #9b59b6;
    --danielle: #3498db;
    --ashley: #f1c40f;
    --nicole: #2ecc71;
    --bartender: #95a5a6;
    --maid: #7f8c8d;
    --lifeguard: #e67e22;
    --dealer: #d35400;
    --receptionist: #34495e;
    
    /* Emotion Colors */
    --joy: #f1c40f;
    --anger: #e74c3c;
    --trust: #2ecc71;
    --anticipation: #3498db;
    --sadness: #9b59b6;
    --disgust: #27ae60;
    --fear: #8e44ad;
    --surprise: #e67e22;
    
    --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    --shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    --shadow-hover: 0 8px 25px rgba(0, 0, 0, 0.4);
}

body {
    background: linear-gradient(135deg, #1a2a6c 0%, #b21f1f 50%, #fdbb2d 100%);
    color: var(--text);
    min-height: 100vh;
    padding: 10px;
    overflow-x: hidden;
    background-attachment: fixed;
}

/* ===== AGE GATE ===== */
.age-gate {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--overlay);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    padding: 20px;
    text-align: center;
    animation: fadeIn 0.5s ease;
}

.age-gate h1 {
    color: var(--warning);
    margin-bottom: 20px;
    font-size: clamp(1.8rem, 5vw, 2.5rem);
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.age-gate p {
    max-width: 600px;
    line-height: 1.6;
    margin-bottom: 30px;
    font-size: clamp(1rem, 3vw, 1.2rem);
    color: var(--text-secondary);
}

.adult-warning {
    background: rgba(232, 67, 147, 0.2);
    border: 2px solid var(--adult);
    padding: 20px;
    border-radius: 12px;
    margin: 25px 0;
    max-width: 600px;
    text-align: left;
}

.adult-warning ul {
    margin: 10px 0 0 25px;
    line-height: 1.8;
}

.adult-warning li {
    margin-bottom: 5px;
}

.age-gate-buttons {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 100%;
    max-width: 350px;
    margin-top: 10px;
}

.age-btn {
    padding: 16px;
    border: none;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: bold;
    cursor: pointer;
    transition: var(--transition);
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
}

.age-confirm {
    background: linear-gradient(135deg, var(--adult), var(--adult-dark));
    color: white;
    box-shadow: 0 4px 15px rgba(232, 67, 147, 0.4);
}

.age-confirm:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(232, 67, 147, 0.6);
}

.age-deny {
    background: linear-gradient(135deg, var(--danger), var(--danger-dark));
    color: white;
    box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
}

.age-deny:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(231, 76, 60, 0.6);
}

/* ===== MAIN CONTAINER ===== */
.main-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    max-width: 1200px;
    margin: 0 auto;
    opacity: 0;
    animation: fadeIn 1s ease forwards;
}

@keyframes fadeIn {
    to { opacity: 1; }
}

/* ===== ENHANCED HEADER ===== */
.game-header {
    background: var(--surface);
    padding: 15px;
    border-radius: 15px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    box-shadow: var(--shadow);
    position: relative;
}

.game-title {
    text-align: center;
    font-size: clamp(1.5rem, 4vw, 2rem);
    color: var(--warning);
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.game-stats {
    display: flex;
    justify-content: space-around;
    flex-wrap: wrap;
    gap: 10px;
}

.stat {
    background: var(--surface-light);
    padding: 8px 15px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
    min-width: 120px;
    justify-content: center;
}

.stat-icon {
    font-size: 1.2rem;
}

.adult-indicator {
    position: absolute;
    top: 15px;
    right: 15px;
    background: linear-gradient(135deg, var(--adult), var(--adult-dark));
    color: white;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: bold;
    display: none;
    animation: pulse 2s infinite;
    box-shadow: 0 4px 15px rgba(232, 67, 147, 0.4);
}

/* ===== ENHANCED MODE INDICATOR ===== */
.enhanced-mode-indicator {
    position: absolute;
    top: 15px;
    left: 15px;
    background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    color: white;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: bold;
    display: none;
    animation: pulse 2s infinite;
    box-shadow: 0 4px 15px rgba(155, 89, 182, 0.4);
}

/* ===== QUEST TRACKER ===== */
.quest-tracker {
    background: var(--surface-dark);
    border-radius: 10px;
    padding: 12px;
    margin-top: 10px;
    display: none;
    border-left: 4px solid var(--warning);
}

.quest-title {
    color: var(--warning);
    margin-bottom: 8px;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.quest-progress {
    height: 10px;
    background: var(--surface-light);
    border-radius: 5px;
    overflow: hidden;
    margin-bottom: 8px;
}

.quest-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--success), var(--warning));
    width: 0%;
    transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* ===== SCENE CONTAINER ===== */
.scene-container {
    background: var(--darker);
    border-radius: 15px;
    overflow: hidden;
    position: relative;
    min-height: 450px;
    height: 450px;
    box-shadow: var(--shadow);
}

.scene {
    width: 100%;
    height: 100%;
    position: relative;
    padding: 20px;
}

.location-name {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    padding: 10px 25px;
    border-radius: 25px;
    font-weight: bold;
    text-transform: uppercase;
    font-size: 0.85rem;
    letter-spacing: 1.5px;
    z-index: 10;
    border: 2px solid var(--warning);
    backdrop-filter: blur(5px);
}

.mood-meter {
    position: absolute;
    top: 15px;
    right: 15px;
    background: rgba(0, 0, 0, 0.7);
    padding: 8px 15px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.8rem;
    z-index: 10;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.mood-fill {
    width: 60px;
    height: 10px;
    background: var(--surface-light);
    border-radius: 5px;
    overflow: hidden;
}

.mood-level {
    height: 100%;
    background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
    transition: width 0.5s ease;
}

/* ===== ENHANCED CHARACTERS ===== */
.character-container {
    position: absolute;
    bottom: 30px;
    left: 20px;
    right: 20px;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    height: 150px;
    z-index: 20;
    gap: 20px;
}

.character, .npc {
    width: 80px;
    height: 130px;
    position: relative;
    transition: var(--transition);
    cursor: pointer;
    flex-shrink: 0;
}

.character:hover, .npc:hover {
    transform: translateY(-8px);
}

.character-body, .npc-body {
    width: 100%;
    height: 100px;
    border-radius: 10px 10px 0 0;
    position: absolute;
    bottom: 0;
}

.character-head, .npc-head {
    width: 65px;
    height: 65px;
    border-radius: 50%;
    position: absolute;
    top: -32px;
    left: 7.5px;
}

.character .character-body {
    background: linear-gradient(135deg, var(--secondary), #2980b9);
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
}

.character .character-head {
    background: linear-gradient(135deg, var(--warning), var(--warning-dark));
    box-shadow: 0 4px 15px rgba(241, 196, 15, 0.4);
}

/* Dynamic NPC colors */
.npc.eve .npc-body { background: linear-gradient(135deg, var(--eve), #c0392b); }
.npc.jessica .npc-body { background: linear-gradient(135deg, var(--jessica), #8e44ad); }
.npc.danielle .npc-body { background: linear-gradient(135deg, var(--danielle), #2980b9); }
.npc.ashley .npc-body { background: linear-gradient(135deg, var(--ashley), var(--warning-dark)); }
.npc.nicole .npc-body { background: linear-gradient(135deg, var(--nicole), var(--success-dark)); }

.npc.eve .npc-head { background: linear-gradient(135deg, #e67e22, #d35400); }
.npc.jessica .npc-head { background: linear-gradient(135deg, #8e44ad, #9b59b6); }
.npc.danielle .npc-head { background: linear-gradient(135deg, #3498db, #2980b9); }
.npc.ashley .npc-head { background: linear-gradient(135deg, var(--warning), #f39c12); }
.npc.nicole .npc-head { background: linear-gradient(135deg, var(--success), #27ae60); }

.character-tooltip, .npc-tooltip {
    position: absolute;
    bottom: -35px;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 0.85rem;
    padding: 6px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(5px);
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

.character:hover .character-tooltip,
.npc:hover .npc-tooltip {
    opacity: 1;
}

/* ===== ENHANCED VISUALS - PARTICLE BACKGROUND ===== */
.particle-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
}

.particle {
    position: absolute;
    border-radius: 50%;
    opacity: 0.3;
    animation: floatParticle 20s infinite linear;
}

@keyframes floatParticle {
    0% { transform: translateY(0) rotate(0deg); }
    100% { transform: translateY(-1000px) rotate(360deg); }
}

/* ===== ENHANCED VISUALS - CHARACTER ANIMATIONS ===== */
.npc.animated {
    animation: npcBreathe 3s ease-in-out infinite;
}

@keyframes npcBreathe {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

.npc.animated .npc-head {
    animation: headTilt 8s ease-in-out infinite;
}

@keyframes headTilt {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(2deg); }
    75% { transform: rotate(-2deg); }
}

/* ===== ENHANCED VISUALS - ITEM GLOW EFFECTS ===== */
.interactive-item.glow {
    animation: pulse-glow 2s ease-in-out infinite, float 3s ease-in-out infinite;
}

.interactive-item.super-glow {
    box-shadow: 0 0 25px rgba(241, 196, 15, 0.8), 0 0 40px rgba(241, 196, 15, 0.4);
    border-color: rgba(241, 196, 15, 0.8);
}

.inventory-item.glow {
    animation: inventoryPulse 2s ease-in-out infinite;
    border-color: var(--warning);
}

@keyframes inventoryPulse {
    0%, 100% { box-shadow: 0 0 10px rgba(241, 196, 15, 0.5); }
    50% { box-shadow: 0 0 20px rgba(241, 196, 15, 0.8); }
}

/* ===== ENHANCED VISUALS - SMOOTH TRANSITIONS ===== */
.scene-transition {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--overlay);
    z-index: 9999;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.smooth-transition {
    transition: var(--transition);
}

/* ===== EMOTION SYSTEM ===== */
.emotion-wheel {
    position: absolute;
    bottom: 180px;
    right: 20px;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    flex-wrap: wrap;
    gap: 5px;
    padding: 10px;
    justify-content: center;
    align-items: center;
    z-index: 25;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.1);
}

.emotion-segment {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.8rem;
    cursor: pointer;
    transition: var(--transition);
    opacity: 0.7;
}

.emotion-segment.active {
    opacity: 1;
    transform: scale(1.2);
    box-shadow: 0 0 15px currentColor;
}

.emotion-segment:hover {
    opacity: 1;
    transform: scale(1.1);
}

.emotion-joy { background: var(--joy); color: #000; }
.emotion-anger { background: var(--anger); }
.emotion-trust { background: var(--trust); color: #000; }
.emotion-anticipation { background: var(--anticipation); }
.emotion-sadness { background: var(--sadness); }
.emotion-disgust { background: var(--disgust); color: #000; }
.emotion-fear { background: var(--fear); }
.emotion-surprise { background: var(--surprise); color: #000; }

.emotion-indicator {
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 10px;
    border-radius: 10px;
    font-size: 0.7rem;
    white-space: nowrap;
    display: none;
}

/* ===== INTERACTIVE ITEMS ===== */
.items-container {
    position: absolute;
    top: 80px;
    left: 0;
    width: 100%;
    height: calc(100% - 180px);
    pointer-events: none;
    overflow: visible;
    padding: 20px;
}

.interactive-item {
    position: absolute;
    width: 55px;
    height: 55px;
    background: var(--primary);
    border-radius: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.8rem;
    cursor: pointer;
    pointer-events: auto;
    transition: var(--transition);
    box-shadow: var(--shadow);
    z-index: 15;
    animation: float 3s ease-in-out infinite;
    will-change: transform;
    border: 3px solid rgba(255, 255, 255, 0.15);
    touch-action: manipulation;
}

.interactive-item:hover {
    transform: scale(1.25) rotate(15deg);
    box-shadow: var(--shadow-hover);
    z-index: 100;
    border-color: rgba(241, 196, 15, 0.6);
}

.interactive-item:active {
    transform: scale(1.15) rotate(10deg);
}

.interactive-item.item-adult {
    background: linear-gradient(135deg, var(--adult), var(--adult-dark));
    border-color: rgba(232, 67, 147, 0.4);
    box-shadow: 0 0 20px rgba(232, 67, 147, 0.5);
}

.interactive-item.item-adult:hover {
    box-shadow: 0 0 30px rgba(232, 67, 147, 0.8);
}

.interactive-item.important {
    animation: float 3s ease-in-out infinite, pulse-glow 2s ease-in-out infinite;
}

.interactive-item.collecting {
    animation: collect 0.6s ease forwards !important;
    pointer-events: none;
}

.interactive-item.respawning {
    opacity: 0.3;
    pointer-events: none;
    animation: respawnPulse 1s ease-in-out infinite;
}

@keyframes float {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-12px) rotate(2deg); }
}

@keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 15px rgba(241, 196, 15, 0.5); }
    50% { box-shadow: 0 0 25px rgba(241, 196, 15, 0.8); }
}

@keyframes collect {
    0% { transform: scale(1) rotate(0deg); opacity: 1; }
    50% { transform: scale(1.4) rotate(180deg); opacity: 0.7; }
    100% { transform: scale(0) rotate(360deg); opacity: 0; }
}

@keyframes respawnPulse {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

/* ===== PANELS CONTAINER ===== */
.panels-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

@media (min-width: 768px) {
    .panels-container {
        flex-direction: row;
    }
}

/* ===== INVENTORY PANEL ===== */
.inventory-panel {
    background: var(--surface);
    border-radius: 15px;
    padding: 15px;
    flex: 1;
    box-shadow: var(--shadow);
    position: relative;
    min-height: 250px;
}

.panel-title {
    font-size: 1.2rem;
    margin-bottom: 15px;
    text-align: center;
    color: var(--warning);
    border-bottom: 2px solid var(--surface-light);
    padding-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.inventory-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 10px;
}

.inventory-item {
    aspect-ratio: 1;
    background: var(--surface-light);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 1.8rem;
    cursor: pointer;
    transition: var(--transition);
    position: relative;
    border: 2px solid transparent;
}

.inventory-item:hover {
    transform: translateY(-5px);
    box-shadow: var(--shadow-hover);
    border-color: var(--warning);
    background: var(--surface);
}

.inventory-item.selected {
    border: 3px solid var(--warning);
    background: var(--surface);
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(241, 196, 15, 0.4);
}

.item-name {
    font-size: 0.65rem;
    margin-top: 5px;
    text-align: center;
    color: var(--text-secondary);
    line-height: 1.2;
    padding: 0 3px;
}

.item-adult-badge {
    position: absolute;
    top: 3px;
    right: 3px;
    background: var(--adult);
    color: white;
    font-size: 0.6rem;
    padding: 2px 5px;
    border-radius: 4px;
    display: none;
    font-weight: bold;
}

/* ===== DIALOG PANEL ===== */
.dialog-panel {
    background: var(--surface);
    border-radius: 15px;
    padding: 15px;
    flex: 2;
    display: flex;
    flex-direction: column;
    box-shadow: var(--shadow);
    min-height: 350px;
}

.dialog-content {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 15px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    min-height: 200px;
    max-height: 300px;
    scroll-behavior: smooth;
}

.message {
    padding: 12px 16px;
    border-radius: 18px;
    max-width: 85%;
    animation: slideIn 0.3s ease;
    word-wrap: break-word;
    line-height: 1.4;
    font-size: 0.95rem;
    position: relative;
    clear: both;
    margin: 5px 0;
    backdrop-filter: blur(5px);
}

@keyframes slideIn {
    from { opacity: 0; transform: translateY(10px) scale(0.95); }
    to { opacity: 1; transform: translateY(0) scale(1); }
}

.message.npc-message {
    background: linear-gradient(135deg, rgba(231, 76, 60, 0.9), rgba(192, 57, 43, 0.9));
    color: white;
    align-self: flex-start;
    border-bottom-left-radius: 5px;
    margin-right: auto;
    box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
    border-left: 4px solid rgba(255, 255, 255, 0.8);
}

.message.player-message {
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.9), rgba(41, 128, 185, 0.9));
    color: white;
    align-self: flex-end;
    border-bottom-right-radius: 5px;
    margin-left: auto;
    box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.2);
    border-right: 4px solid rgba(255, 255, 255, 0.8);
}

.message.adult-message {
    background: linear-gradient(135deg, rgba(232, 67, 147, 0.9), rgba(214, 48, 49, 0.9));
    border-color: var(--adult-light);
}

.dialog-options {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
    max-height: 150px;
    overflow-y: auto;
    padding-right: 5px;
}

.dialog-option {
    background: var(--surface-light);
    padding: 12px;
    border-radius: 10px;
    cursor: pointer;
    transition: var(--transition);
    font-size: 0.85rem;
    border: 2px solid transparent;
}

.dialog-option:hover {
    background: var(--primary);
    transform: translateY(-2px);
    border-color: var(--warning);
    box-shadow: var(--shadow);
}

.dialog-option.adult-option {
    background: rgba(232, 67, 147, 0.2);
    border: 2px dashed var(--adult);
}

.dialog-option.adult-option:hover {
    background: var(--adult);
    border-style: solid;
}

.dialog-option.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: var(--surface) !important;
    transform: none !important;
    border-color: transparent !important;
    box-shadow: none !important;
}

/* ===== COMMENTS PANEL ===== */
.comments-panel {
    background: var(--surface);
    border-radius: 15px;
    padding: 15px;
    box-shadow: var(--shadow);
}

.comments-container {
    max-height: 200px;
    overflow-y: auto;
    padding-right: 5px;
}

.comment {
    background: rgba(255, 255, 255, 0.05);
    padding: 12px;
    border-radius: 10px;
    margin-bottom: 10px;
    animation: fadeInUp 0.5s ease;
    border-left: 4px solid var(--warning);
    backdrop-filter: blur(5px);
}

.comment.adult-comment {
    border-left-color: var(--adult);
    background: rgba(232, 67, 147, 0.1);
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.comment-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 0.8rem;
    color: var(--warning);
    font-weight: bold;
}

.comment-text {
    font-style: italic;
    font-size: 0.9rem;
    line-height: 1.4;
}

/* ===== ENHANCED UI ELEMENTS ===== */

/* NPC Selector Panel */
.npc-selector-panel {
    background: var(--surface);
    border-radius: 15px;
    padding: 15px;
    margin-top: 10px;
    box-shadow: var(--shadow);
    display: none;
}

.npc-selector-title {
    font-size: 1.1rem;
    margin-bottom: 15px;
    text-align: center;
    color: var(--warning);
    border-bottom: 2px solid var(--surface-light);
    padding-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.npc-selector-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
    gap: 12px;
}

.npc-portrait {
    aspect-ratio: 3/4;
    background: var(--surface-light);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    align-items: center;
    cursor: pointer;
    transition: var(--transition);
    position: relative;
    border: 3px solid transparent;
    overflow: hidden;
    padding: 10px;
}

.npc-portrait:hover {
    transform: translateY(-5px);
    box-shadow: var(--shadow-hover);
}

.npc-portrait.active {
    border-color: var(--warning);
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(241, 196, 15, 0.4);
}

.npc-portrait.eve { background: linear-gradient(135deg, var(--eve), #c0392b); }
.npc-portrait.jessica { background: linear-gradient(135deg, var(--jessica), #8e44ad); }
.npc-portrait.danielle { background: linear-gradient(135deg, var(--danielle), #2980b9); }
.npc-portrait.ashley { background: linear-gradient(135deg, var(--ashley), var(--warning-dark)); }
.npc-portrait.nicole { background: linear-gradient(135deg, var(--nicole), var(--success-dark)); }

.npc-avatar {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.8rem;
    margin-bottom: 10px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.npc-name {
    font-size: 0.8rem;
    text-align: center;
    color: white;
    font-weight: bold;
    margin-bottom: 5px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.npc-relationship {
    font-size: 0.7rem;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 3px;
}

/* Relationships Panel */
.relationships-panel {
    background: var(--surface);
    border-radius: 15px;
    padding: 15px;
    margin-top: 10px;
    box-shadow: var(--shadow);
    display: none;
}

.relationship-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    margin-bottom: 8px;
    background: var(--surface-light);
    border-radius: 10px;
    transition: var(--transition);
}

.relationship-item:hover {
    transform: translateX(5px);
    background: var(--surface);
}

.relationship-info {
    display: flex;
    align-items: center;
    gap: 10px;
}

.relationship-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.2rem;
}

.relationship-name {
    font-weight: bold;
    font-size: 0.9rem;
}

.relationship-location {
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.relationship-meter {
    width: 100px;
    height: 8px;
    background: var(--surface-dark);
    border-radius: 4px;
    overflow: hidden;
}

.relationship-level {
    height: 100%;
    border-radius: 4px;
    transition: width 0.5s ease;
}

.relationship-value {
    font-size: 0.8rem;
    font-weight: bold;
    min-width: 30px;
    text-align: right;
}

/* NPC Dialog Indicator */
.npc-dialog-indicator {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
}

.current-npc-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.5rem;
    background: rgba(255, 255, 255, 0.1);
}

.current-npc-info {
    flex: 1;
}

.current-npc-name {
    font-weight: bold;
    font-size: 1.1rem;
}

.current-npc-mood {
    font-size: 0.8rem;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 5px;
}

/* Jealousy Indicator */
.jealousy-indicator {
    position: fixed;
    top: 80px;
    right: 20px;
    background: rgba(231, 76, 60, 0.9);
    color: white;
    padding: 12px 20px;
    border-radius: 10px;
    z-index: 1000;
    display: none;
    align-items: center;
    gap: 10px;
    animation: shake 0.5s ease;
    backdrop-filter: blur(5px);
    border: 2px solid rgba(255, 255, 255, 0.2);
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* Date Scheduler */
.date-scheduler {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--surface);
    padding: 25px;
    border-radius: 15px;
    box-shadow: var(--shadow-hover);
    z-index: 4000;
    display: none;
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow-y: auto;
}

.date-npc-select, .date-location-select {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
    margin: 15px 0;
}

.date-option {
    padding: 12px;
    background: var(--surface-light);
    border-radius: 10px;
    text-align: center;
    cursor: pointer;
    transition: var(--transition);
}

.date-option:hover {
    transform: scale(1.05);
    background: var(--primary);
}

.date-option.selected {
    background: var(--primary);
    border: 2px solid var(--warning);
}

.date-time-select {
    display: flex;
    gap: 10px;
    margin: 15px 0;
}

.date-time-option {
    flex: 1;
    padding: 10px;
    background: var(--surface-light);
    border-radius: 8px;
    text-align: center;
    cursor: pointer;
}

.date-time-option.selected {
    background: var(--primary);
}

/* Date Scene */
.date-scene {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--darker);
    z-index: 5000;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
}

.date-background {
    width: 100%;
    height: 100%;
    position: absolute;
    background-size: cover;
    background-position: center;
    filter: brightness(0.7);
}

.date-content {
    position: relative;
    z-index: 10;
    background: rgba(0, 0, 0, 0.8);
    padding: 30px;
    border-radius: 15px;
    max-width: 800px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.date-npc-dialogue {
    font-size: 1.2rem;
    line-height: 1.6;
    margin-bottom: 20px;
    font-style: italic;
}

.date-choices {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.date-choice {
    padding: 15px;
    background: var(--surface-light);
    border-radius: 10px;
    cursor: pointer;
    transition: var(--transition);
}

.date-choice:hover {
    background: var(--primary);
    transform: translateY(-3px);
}

/* Ending Gallery */
.ending-gallery {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--overlay);
    z-index: 6000;
    display: none;
    padding: 20px;
    overflow-y: auto;
}

.ending-card {
    background: var(--surface);
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 20px;
    box-shadow: var(--shadow);
    max-width: 800px;
    margin: 20px auto;
}

.ending-title {
    color: var(--warning);
    font-size: 1.5rem;
    margin-bottom: 10px;
    text-align: center;
}

.ending-npc {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.ending-description {
    line-height: 1.6;
    margin-bottom: 15px;
}

.ending-requirements {
    background: rgba(0, 0, 0, 0.2);
    padding: 15px;
    border-radius: 10px;
    font-size: 0.9rem;
}

/* ===== STORY ENGINE PANEL ===== */
.story-engine-panel {
    background: var(--surface);
    border-radius: 15px;
    padding: 15px;
    margin-top: 10px;
    box-shadow: var(--shadow);
    display: none;
}

.story-progress {
    background: var(--surface-light);
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
}

.story-milestone {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
    padding: 8px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.05);
}

.story-milestone.unlocked {
    background: rgba(46, 204, 113, 0.1);
    border-left: 4px solid var(--success);
}

.story-milestone.locked {
    opacity: 0.5;
}

/* ===== ACHIEVEMENTS PANEL ===== */
.achievements-panel {
    background: var(--surface);
    border-radius: 15px;
    padding: 15px;
    margin-top: 10px;
    box-shadow: var(--shadow);
    display: none;
}

.achievement-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
}

.achievement {
    aspect-ratio: 1;
    background: var(--surface-light);
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 10px;
    text-align: center;
    cursor: pointer;
    transition: var(--transition);
}

.achievement.unlocked {
    background: linear-gradient(135deg, var(--warning), var(--warning-dark));
}

.achievement.locked {
    opacity: 0.5;
    filter: grayscale(1);
}

/* ===== ANALYTICS DASHBOARD ===== */
.analytics-panel {
    background: var(--surface);
    border-radius: 15px;
    padding: 15px;
    margin-top: 10px;
    box-shadow: var(--shadow);
    display: none;
}

.relationship-graph {
    height: 200px;
    background: var(--surface-dark);
    border-radius: 10px;
    padding: 10px;
    position: relative;
    overflow: hidden;
}

.graph-line {
    position: absolute;
    bottom: 0;
    height: 2px;
    background: var(--primary);
    transition: width 0.5s ease;
}

/* ===== MINI-GAMES ===== */
.mini-game-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--surface);
    padding: 25px;
    border-radius: 15px;
    box-shadow: var(--shadow-hover);
    z-index: 7000;
    display: none;
    width: 90%;
    max-width: 600px;
}

.poker-table {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    margin: 20px 0;
}

.poker-card {
    aspect-ratio: 2/3;
    background: white;
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2rem;
    color: black;
    cursor: pointer;
    transition: var(--transition);
}

.poker-card:hover {
    transform: translateY(-5px);
}

/* ===== ACTION BUTTONS ===== */
.action-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
}

@media (min-width: 480px) {
    .action-buttons {
        grid-template-columns: repeat(4, 1fr);
    }
}

.btn {
    padding: 14px;
    border: none;
    border-radius: 12px;
    background: var(--surface-light);
    color: var(--text);
    font-weight: bold;
    cursor: pointer;
    transition: var(--transition);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    font-size: 0.9rem;
    border: 2px solid transparent;
    touch-action: manipulation;
}

.btn:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-hover);
    border-color: var(--warning);
}

.btn:active {
    transform: translateY(-1px);
}

.btn-primary {
    background: linear-gradient(135deg, var(--secondary), #2980b9);
}

.btn-success {
    background: linear-gradient(135deg, var(--success), var(--success-dark));
}

.btn-danger {
    background: linear-gradient(135deg, var(--danger), var(--danger-dark));
}

.btn-warning {
    background: linear-gradient(135deg, var(--warning), var(--warning-dark));
}

.btn-adult {
    background: linear-gradient(135deg, var(--adult), var(--adult-dark));
}

.btn-icon {
    font-size: 1.2rem;
}

/* ===== FOOTER ===== */
.game-footer {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

@media (min-width: 768px) {
    .game-footer {
        flex-direction: row;
        justify-content: space-between;
    }
}

/* ===== NOTIFICATION ===== */
.notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    background: var(--success);
    color: white;
    padding: 16px 30px;
    border-radius: 12px;
    z-index: 2000;
    opacity: 0;
    transition: opacity 0.3s, transform 0.3s;
    box-shadow: var(--shadow-hover);
    max-width: 90%;
    text-align: center;
    font-weight: bold;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.2);
}

.notification.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

.notification.adult {
    background: linear-gradient(135deg, var(--adult), var(--adult-dark));
}

.notification.warning {
    background: linear-gradient(135deg, var(--warning), var(--warning-dark));
}

.notification.error {
    background: linear-gradient(135deg, var(--danger), var(--danger-dark));
}

/* ===== AI CONTROLS ===== */
.ai-controls {
    position: absolute;
    bottom: 15px;
    left: 15px;
    z-index: 30;
    display: flex;
    gap: 10px;
}

.ai-toggle, .enhanced-toggle {
    background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    color: white;
    border: none;
    padding: 10px 18px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: var(--transition);
    border: 2px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(5px);
}

.ai-toggle:hover, .enhanced-toggle:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow);
    border-color: var(--warning);
}

/* ===== MINI-MAP ===== */
.mini-map {
    position: absolute;
    bottom: 15px;
    right: 15px;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px;
    border-radius: 15px;
    display: flex;
    gap: 8px;
    z-index: 30;
    backdrop-filter: blur(5px);
    border: 2px solid rgba(255, 255, 255, 0.1);
}

.map-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--surface-light);
    cursor: pointer;
    transition: var(--transition);
}

.map-dot:hover {
    transform: scale(1.3);
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
}

.map-dot.active {
    background: var(--warning);
    box-shadow: 0 0 15px var(--warning);
    transform: scale(1.2);
}

.map-dot.locked {
    background: #7f8c8d;
    opacity: 0.5;
    cursor: not-allowed;
}

.map-dot.locked:hover {
    transform: none;
    box-shadow: none;
}

/* ===== LOADING INDICATOR ===== */
.loading {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--overlay);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 3000;
    gap: 20px;
    display: none;
}

.spinner {
    width: 60px;
    height: 60px;
    border: 5px solid rgba(255, 255, 255, 0.1);
    border-top-color: var(--warning);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.loading-text {
    color: var(--text);
    font-size: 1.2rem;
    animation: pulse 2s infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar {
    width: 10px;
}

::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: var(--primary);
    border-radius: 10px;
    border: 2px solid transparent;
    background-clip: padding-box;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--primary-dark);
    background-clip: padding-box;
}

/* ===== ACCESSIBILITY ===== */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* ===== MOBILE OPTIMIZATIONS ===== */
@media (max-width: 767px) {
    .scene-container {
        min-height: 350px;
        height: 350px;
    }
    
    .character-container {
        height: 120px;
        bottom: 20px;
        gap: 10px;
    }
    
    .character, .npc {
        width: 60px;
        height: 100px;
    }
    
    .character-body, .npc-body {
        height: 75px;
    }
    
    .character-head, .npc-head {
        width: 50px;
        height: 50px;
        top: -25px;
        left: 5px;
    }
    
    .interactive-item {
        width: 45px;
        height: 45px;
        font-size: 1.5rem;
        min-width: 44px;
        min-height: 44px;
    }
    
    .items-container {
        top: 60px;
        height: calc(100% - 140px);
        padding: 15px;
    }
    
    .dialog-options {
        grid-template-columns: 1fr;
    }
    
    .btn {
        padding: 12px;
        font-size: 0.85rem;
    }
    
    .message {
        max-width: 90%;
        padding: 10px 14px;
        font-size: 0.9rem;
    }
    
    .action-buttons {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .game-stats {
        flex-direction: column;
        align-items: stretch;
    }
    
    .stat {
        width: 100%;
        justify-content: space-between;
    }
    
    .mood-meter {
        flex-direction: column;
        gap: 5px;
        align-items: flex-start;
        padding: 8px 12px;
    }
    
    .npc-selector-grid {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .ai-controls {
        flex-direction: column;
        gap: 5px;
    }
    
    .emotion-wheel {
        width: 100px;
        height: 100px;
        bottom: 160px;
    }
    
    .emotion-segment {
        width: 25px;
        height: 25px;
        font-size: 0.7rem;
    }
}

@media (max-width: 480px) {
    .scene-container {
        min-height: 300px;
        height: 300px;
    }
    
    .character-container {
        height: 100px;
        bottom: 15px;
    }
    
    .character, .npc {
        width: 50px;
        height: 80px;
    }
    
    .character-body, .npc-body {
        height: 60px;
    }
    
    .character-head, .npc-head {
        width: 40px;
        height: 40px;
        top: -20px;
        left: 5px;
    }
    
    .action-buttons {
        grid-template-columns: 1fr;
    }
    
    .game-footer {
        gap: 10px;
    }
    
    .inventory-grid {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .npc-selector-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .npc-portrait {
        aspect-ratio: 1/1;
    }
}
    </style>
</head>
<body>
    <!-- Age Gate -->
    <div class="age-gate" id="age-gate" role="dialog" aria-labelledby="age-gate-title" aria-describedby="age-gate-description">
        <h1 id="age-gate-title">‚ö†Ô∏è ADULT CONTENT WARNING</h1>
        <p id="age-gate-description">This game contains mature themes, explicit dialogue, adult humor, and suggestive content intended for players 18 years and older.</p>
        
        <div class="adult-warning" role="alert">
            <p>‚ö†Ô∏è Content includes:</p>
            <ul>
                <li>Sexual themes and innuendo</li>
                <li>Explicit romantic encounters</li>
                <li>Adult-oriented humor</li>
                <li>Suggestive situations</li>
            </ul>
        </div>
        
        <div class="age-gate-buttons">
            <button class="age-btn age-confirm" id="age-confirm" aria-label="I am 18 or older, enter game">
                <span>‚úÖ</span>
                I AM 18+ - ENTER GAME
            </button>
            <button class="age-btn age-deny" id="age-deny" aria-label="I am under 18, exit">
                <span>üö´</span>
                I AM UNDER 18 - EXIT
            </button>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div class="loading" id="loading">
        <div class="spinner" aria-hidden="true"></div>
        <div class="loading-text" id="loading-text">Loading...</div>
    </div>

    <!-- Main Game Container -->
    <div class="main-container" id="game-container" style="display: none;" aria-hidden="true">
        <!-- Enhanced Header -->
        <header class="game-header" role="banner">
            <h1 class="game-title">Leisure Suit Larry: Enhanced Multi-NPC Adventures</h1>
            <div class="adult-indicator" id="adult-indicator" aria-label="Adult Mode Enabled">ADULT MODE</div>
            <div class="enhanced-mode-indicator" id="enhanced-mode-indicator" aria-label="Enhanced Mode Enabled">ENHANCED MODE</div>
            <div class="game-stats" role="status" aria-label="Game statistics">
                <div class="stat">
                    <span class="stat-icon" aria-hidden="true">üèÜ</span>
                    <span>Score: <span id="score-value">250</span></span>
                </div>
                <div class="stat">
                    <span class="stat-icon" aria-hidden="true">‚è±Ô∏è</span>
                    <span>Time: <span id="time-value">12:45</span></span>
                </div>
                <div class="stat">
                    <span class="stat-icon" aria-hidden="true">‚ù§Ô∏è</span>
                    <span>Relationship: <span id="relationship-value">15</span></span>
                </div>
                <div class="stat">
                    <span class="stat-icon" aria-hidden="true">üéØ</span>
                    <span>Progress: <span id="progress-value">0%</span></span>
                </div>
                <div class="stat">
                    <span class="stat-icon" aria-hidden="true">üë•</span>
                    <span>NPCs: <span id="npc-count">1/5</span></span>
                </div>
            </div>
            
            <!-- Enhanced Mode Toggle Button -->
            <button class="btn btn-primary" id="enhanced-mode-toggle" style="width: 100%; margin-top: 5px;">
                <span class="btn-icon">üåü</span>
                <span id="enhanced-mode-text">Enable Enhanced Mode</span>
            </button>
            
            <!-- Quest Tracker -->
            <div class="quest-tracker" id="quest-tracker" role="status" aria-label="Quest progress">
                <div class="quest-title">
                    <span>üìã</span>
                    <span>Current Quest: <span id="current-quest">Get Eve's attention</span></span>
                </div>
                <div class="quest-progress">
                    <div class="quest-bar" id="quest-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>
                </div>
                <div class="quest-description" id="quest-description"></div>
            </div>
        </header>

        <!-- Enhanced NPC Selector Panel -->
        <section class="npc-selector-panel" id="npc-selector-panel" aria-labelledby="npc-selector-title">
            <h3 class="npc-selector-title" id="npc-selector-title">
                <span>üë•</span>
                <span>Select NPC to Interact With</span>
            </h3>
            <div class="npc-selector-grid" id="npc-selector-grid" role="grid">
                <!-- NPC portraits will be added here -->
            </div>
        </section>

        <!-- Relationships Panel -->
        <section class="relationships-panel" id="relationships-panel" aria-labelledby="relationships-title">
            <h3 class="panel-title" id="relationships-title">
                <span>üíù</span>
                <span>Your Relationships</span>
            </h3>
            <div id="relationships-list" role="list">
                <!-- Relationship items will be added here -->
            </div>
        </section>

        <!-- Story Engine Panel -->
        <section class="story-engine-panel" id="story-engine-panel" aria-labelledby="story-engine-title">
            <h3 class="panel-title" id="story-engine-title">
                <span>üìñ</span>
                <span>Story Progress</span>
            </h3>
            <div id="story-progress-content"></div>
        </section>

        <!-- Achievements Panel -->
        <section class="achievements-panel" id="achievements-panel" aria-labelledby="achievements-title">
            <h3 class="panel-title" id="achievements-title">
                <span>üèÜ</span>
                <span>Achievements</span>
            </h3>
            <div class="achievement-grid" id="achievements-grid"></div>
        </section>

        <!-- Analytics Panel -->
        <section class="analytics-panel" id="analytics-panel" aria-labelledby="analytics-title">
            <h3 class="panel-title" id="analytics-title">
                <span>üìä</span>
                <span>Relationship Analytics</span>
            </h3>
            <div class="relationship-graph" id="relationship-graph"></div>
        </section>

        <!-- Game Content -->
        <main class="game-content" role="main">
            <!-- Scene -->
            <div class="scene-container">
                <div class="scene" id="scene">
                    <div class="particle-background" id="particle-background"></div>
                    <div class="scene-transition" id="scene-transition"></div>
                    
                    <div class="location-name" id="location-name">Le Bar de l'Amour</div>
                    
                    <!-- Emotion Wheel -->
                    <div class="emotion-wheel" id="emotion-wheel">
                        <div class="emotion-indicator" id="emotion-indicator"></div>
                        <div class="emotion-segment emotion-joy" data-emotion="joy" title="Joy">üòä</div>
                        <div class="emotion-segment emotion-anger" data-emotion="anger" title="Anger">üò†</div>
                        <div class="emotion-segment emotion-trust" data-emotion="trust" title="Trust">ü§ù</div>
                        <div class="emotion-segment emotion-anticipation" data-emotion="anticipation" title="Anticipation">ü§î</div>
                        <div class="emotion-segment emotion-sadness" data-emotion="sadness" title="Sadness">üò¢</div>
                        <div class="emotion-segment emotion-disgust" data-emotion="disgust" title="Disgust">ü§¢</div>
                        <div class="emotion-segment emotion-fear" data-emotion="fear" title="Fear">üò®</div>
                        <div class="emotion-segment emotion-surprise" data-emotion="surprise" title="Surprise">üò≤</div>
                    </div>
                    
                    <!-- Enhanced NPC Dialog Indicator -->
                    <div class="npc-dialog-indicator" id="npc-dialog-indicator">
                        <div class="current-npc-avatar" id="current-npc-avatar">üë©</div>
                        <div class="current-npc-info">
                            <div class="current-npc-name" id="current-npc-name">Eve</div>
                            <div class="current-npc-mood">
                                <span>Mood: <span id="current-npc-mood">50</span></span>
                                <span>Relationship: <span id="current-npc-relationship">15</span></span>
                                <span id="npc-emotion-display"></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mood-meter">
                        <span>Mood:</span>
                        <div class="mood-fill">
                            <div class="mood-level" id="mood-level" style="width: 50%;" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="50"></div>
                        </div>
                    </div>
                    
                    <div class="character-container">
                        <div class="character" id="player-character" role="button" tabindex="0" aria-label="Player character Larry">
                            <div class="character-body"></div>
                            <div class="character-head"></div>
                            <div class="character-tooltip">Larry</div>
                        </div>
                        <div class="npc eve animated" id="eve-character" role="button" tabindex="0" aria-label="NPC character Eve">
                            <div class="npc-body"></div>
                            <div class="npc-head"></div>
                            <div class="npc-tooltip">Eve</div>
                        </div>
                        <!-- Additional NPCs will be dynamically added -->
                    </div>
                    
                    <div class="items-container" id="items-container">
                        <!-- Interactive items will be added here -->
                    </div>
                    
                    <div class="ai-controls">
                        <button class="ai-toggle" id="ai-toggle" aria-label="Toggle AI mode">
                            <span>ü§ñ</span>
                            <span id="ai-status">AI: ON</span>
                        </button>
                        <button class="enhanced-toggle" id="npc-selector-toggle-btn" aria-label="Toggle NPC selector">
                            <span>üë•</span>
                            <span>Switch NPC</span>
                        </button>
                        <button class="enhanced-toggle" id="emotion-wheel-toggle" aria-label="Toggle emotion wheel">
                            <span>üíñ</span>
                            <span>Emotions</span>
                        </button>
                    </div>
                    
                    <div class="mini-map" id="mini-map" role="navigation" aria-label="Location map">
                        <!-- Mini-map dots will be added here -->
                    </div>
                </div>
            </div>

            <!-- Panels -->
            <div class="panels-container">
                <!-- Inventory -->
                <section class="inventory-panel" aria-labelledby="inventory-title">
                    <h3 class="panel-title" id="inventory-title">
                        <span aria-hidden="true">üéí</span>
                        <span>Inventory (<span id="inventory-count">0</span>/12)</span>
                    </h3>
                    <div class="inventory-grid" id="inventory-grid" role="grid">
                        <!-- Inventory items will be added here -->
                    </div>
                </section>

                <!-- Dialog -->
                <section class="dialog-panel" aria-labelledby="dialog-title">
                    <h3 class="panel-title" id="dialog-title">
                        <span aria-hidden="true">üí¨</span>
                        <span>Conversation with <span id="current-npc">Eve</span></span>
                    </h3>
                    <div class="dialog-content" id="dialog-content" role="log" aria-live="polite">
                        <!-- Messages will be added here -->
                    </div>
                    <div class="dialog-options" id="dialog-options" role="menu">
                        <!-- Dialog options will be added here -->
                    </div>
                </section>
            </div>

            <!-- Comments -->
            <section class="comments-panel" aria-labelledby="comments-title">
                <h3 class="panel-title" id="comments-title">
                    <span aria-hidden="true">üí≠</span>
                    <span>NPC Thoughts</span>
                </h3>
                <div class="comments-container" id="comments-container" role="list">
                    <!-- Comments will be added here -->
                </div>
            </section>

            <!-- Enhanced Footer -->
            <footer class="game-footer" role="contentinfo">
                <div class="action-buttons">
                    <button class="btn btn-primary" id="look-btn" aria-label="Look around">
                        <span class="btn-icon" aria-hidden="true">üëÅÔ∏è</span>
                        <span>Look</span>
                    </button>
                    <button class="btn btn-primary" id="talk-btn" aria-label="Talk to NPC">
                        <span class="btn-icon" aria-hidden="true">üí¨</span>
                        <span>Talk</span>
                    </button>
                    <button class="btn btn-warning" id="use-btn" aria-label="Use selected item">
                        <span class="btn-icon" aria-hidden="true">üéØ</span>
                        <span>Use Item</span>
                    </button>
                    <button class="btn btn-success" id="move-btn" aria-label="Move to next location">
                        <span class="btn-icon" aria-hidden="true">üö∂</span>
                        <span>Move</span>
                    </button>
                    <button class="btn" id="examine-btn" aria-label="Examine current location">
                        <span class="btn-icon" aria-hidden="true">üîç</span>
                        <span>Examine</span>
                    </button>
                    <button class="btn btn-adult" id="flirt-btn" aria-label="Flirt with NPC">
                        <span class="btn-icon" aria-hidden="true">üíã</span>
                        <span>Flirt</span>
                    </button>
<button class="btn btn-adult" id="buy-condoms-btn" aria-label="Buy protection">
    <span class="btn-icon">üõí</span>
    <span>Buy Protection</span>
</button>
                    <button class="btn" id="quest-info-btn" aria-label="Show quest information">
                        <span class="btn-icon" aria-hidden="true">üìã</span>
                        <span>Quest Info</span>
                    </button>
                </div>
                
                <div class="action-buttons">
                    <button class="btn" id="save-btn" aria-label="Save game">
                        <span class="btn-icon" aria-hidden="true">üíæ</span>
                        <span>Save</span>
                    </button>
                    <button class="btn" id="load-btn" aria-label="Load saved game">
                        <span class="btn-icon" aria-hidden="true">üìÇ</span>
                        <span>Load</span>
                    </button>
                    <button class="btn btn-danger" id="reset-btn" aria-label="Reset game">
                        <span class="btn-icon" aria-hidden="true">üîÑ</span>
                        <span>Reset</span>
                    </button>
                    <button class="btn btn-adult" id="date-btn" aria-label="Schedule a date">
                        <span class="btn-icon" aria-hidden="true">üìÖ</span>
                        <span>Schedule Date</span>
                    </button>
                    <button class="btn" id="relationships-btn" aria-label="View relationships">
                        <span class="btn-icon" aria-hidden="true">üíù</span>
                        <span>Relationships</span>
                    </button>
                    <button class="btn" id="endings-btn" aria-label="View unlocked endings">
                        <span class="btn-icon" aria-hidden="true">üèÜ</span>
                        <span>Endings</span>
                    </button>
                    <button class="btn" id="achievements-btn" aria-label="View achievements">
                        <span class="btn-icon" aria-hidden="true">üèÖ</span>
                        <span>Achievements</span>
                    </button>
                    <button class="btn" id="analytics-btn" aria-label="View analytics">
                        <span class="btn-icon" aria-hidden="true">üìä</span>
                        <span>Analytics</span>
                    </button>
                    <button class="btn" id="story-btn" aria-label="View story progress">
                        <span class="btn-icon" aria-hidden="true">üìñ</span>
                        <span>Story</span>
                    </button>
                    <button class="btn" id="mini-game-btn" aria-label="Play mini-game">
                        <span class="btn-icon" aria-hidden="true">üéÆ</span>
                        <span>Mini-Game</span>
                    </button>
                </div>
            </footer>
        </main>
    </div>

    <!-- Enhanced UI Elements -->
    <div class="jealousy-indicator" id="jealousy-indicator" role="alert" aria-live="assertive">
        <span>‚ö†Ô∏è</span>
        <span id="jealousy-text">Eve is getting jealous!</span>
    </div>
    
    <div class="date-scheduler" id="date-scheduler" role="dialog" aria-labelledby="date-scheduler-title">
        <h3 id="date-scheduler-title">Schedule a Date</h3>
        <div class="date-npc-select" id="date-npc-select" role="listbox"></div>
        <div class="date-location-select" id="date-location-select" role="listbox"></div>
        <div class="date-time-select" id="date-time-select" role="listbox"></div>
        <button class="btn btn-success" id="confirm-date">Confirm Date</button>
        <button class="btn btn-danger" id="cancel-date">Cancel</button>
    </div>
    
    <div class="date-scene" id="date-scene" role="dialog" aria-labelledby="date-scene-title">
        <div class="date-background" id="date-background"></div>
        <div class="date-content" id="date-content"></div>
    </div>
    
    <div class="ending-gallery" id="ending-gallery" role="dialog" aria-labelledby="ending-gallery-title">
        <h2 id="ending-gallery-title">Endings Unlocked</h2>
        <div id="endings-container"></div>
        <button class="btn btn-danger" id="close-endings">Close</button>
    </div>

    <!-- Mini-Game Panel -->
    <div class="mini-game-panel" id="mini-game-panel">
        <h3 id="mini-game-title">Poker</h3>
        <div class="poker-table" id="poker-table"></div>
        <div class="action-buttons">
            <button class="btn btn-success" id="deal-poker">Deal</button>
            <button class="btn btn-danger" id="fold-poker">Fold</button>
            <button class="btn btn-warning" id="bet-poker">Bet $50</button>
            <button class="btn" id="close-mini-game">Close</button>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification" role="alert" aria-live="assertive"></div>

<script>
// ===== ENHANCED SYSTEMS MODULES =====

// ===== EMOTION SYSTEM =====
const EmotionSystem = (() => {
    const emotions = {
        joy: { emoji: 'üòä', color: 'var(--joy)', intensity: 0, modifiers: { mood: 1.2, response: 1.3 } },
        anger: { emoji: 'üò†', color: 'var(--anger)', intensity: 0, modifiers: { mood: 0.8, response: 0.7 } },
        trust: { emoji: 'ü§ù', color: 'var(--trust)', intensity: 0, modifiers: { mood: 1.1, response: 1.2 } },
        anticipation: { emoji: 'ü§î', color: 'var(--anticipation)', intensity: 0, modifiers: { mood: 1.0, response: 1.1 } },
        sadness: { emoji: 'üò¢', color: 'var(--sadness)', intensity: 0, modifiers: { mood: 0.9, response: 0.9 } },
        disgust: { emoji: 'ü§¢', color: 'var(--disgust)', intensity: 0, modifiers: { mood: 0.7, response: 0.8 } },
        fear: { emoji: 'üò®', color: 'var(--fear)', intensity: 0, modifiers: { mood: 0.8, response: 0.9 } },
        surprise: { emoji: 'üò≤', color: 'var(--surprise)', intensity: 0, modifiers: { mood: 1.0, response: 1.1 } }
    };

    const emotionMemory = new Map(); // Stores emotional memories per NPC

    const getEmotion = (npcName) => {
        if (!emotionMemory.has(npcName)) {
            emotionMemory.set(npcName, { current: 'anticipation', intensity: 50 });
        }
        return emotionMemory.get(npcName);
    };

    const setEmotion = (npcName, emotion, intensity = 50) => {
        const currentEmotion = getEmotion(npcName);
        currentEmotion.current = emotion;
        currentEmotion.intensity = Math.max(0, Math.min(100, intensity));
        
        // Add to memory
        if (!currentEmotion.history) currentEmotion.history = [];
        currentEmotion.history.push({
            emotion,
            intensity,
            timestamp: Date.now(),
            location: IntegratedGameState.getState().currentLocation
        });
        
        // Keep only last 10 emotional memories
        if (currentEmotion.history.length > 10) {
            currentEmotion.history.shift();
        }
        
        emotionMemory.set(npcName, currentEmotion);
        updateEmotionDisplay(npcName);
    };

    const influenceEmotion = (npcName, emotion, amount) => {
        const current = getEmotion(npcName);
        if (current.current === emotion) {
            current.intensity = Math.max(0, Math.min(100, current.intensity + amount));
        } else {
            // If different emotion, gradually switch
            current.intensity = Math.max(0, Math.min(100, current.intensity - amount));
            if (current.intensity <= 30) {
                setEmotion(npcName, emotion, 50);
            }
        }
        emotionMemory.set(npcName, current);
        updateEmotionDisplay(npcName);
    };

    const getEmotionModifier = (npcName, type) => {
        const emotion = getEmotion(npcName);
        const modifiers = emotions[emotion.current]?.modifiers || { mood: 1.0, response: 1.0 };
        return modifiers[type] || 1.0;
    };

    const updateEmotionDisplay = (npcName) => {
        const emotion = getEmotion(npcName);
        const display = document.getElementById('npc-emotion-display');
        if (display && emotion && emotions[emotion.current]) {
            display.innerHTML = `${emotions[emotion.current].emoji} ${emotion.current} (${emotion.intensity})`;
            display.style.color = emotions[emotion.current].color;
        } else if (display) {
            display.innerHTML = 'üòê neutral (50)';
            display.style.color = 'var(--text-secondary)';
        }
    };

    const getEmotionResponse = (npcName, dialogType) => {
        const emotion = getEmotion(npcName);
        const responses = {
            joy: {
                compliment: ["You're making me smile!", "That's so sweet of you!", "I'm really happy right now!"],
                insult: ["That's not nice...", "Why would you say that?", "I was having such a good mood..."]
            },
            anger: {
                compliment: ["Save it.", "Too little too late.", "I'm not in the mood."],
                insult: ["How dare you!", "That's it, I'm done!", "You've crossed a line!"]
            },
            trust: {
                compliment: ["I feel I can really open up to you.", "You're so understanding.", "I trust you completely."],
                insult: ["I thought I could trust you...", "This really hurts coming from you.", "My trust was misplaced."]
            }
        };

        const emotionResponses = responses[emotion.current]?.[dialogType] || ["I see.", "Interesting.", "Okay."];
        return emotionResponses[Math.floor(Math.random() * emotionResponses.length)];
    };

    const initializeEmotionWheel = () => {
        const wheel = document.getElementById('emotion-wheel');
        const indicator = document.getElementById('emotion-indicator');
        
        if (!wheel || !indicator) return;

        // Add click events to emotion segments
        const segments = wheel.querySelectorAll('.emotion-segment');
        segments.forEach(segment => {
            segment.addEventListener('click', () => {
                const emotion = segment.dataset.emotion;
                const state = IntegratedGameState.getState();
                const npcName = state.currentNPC;
                
                // Show which emotion was selected
                indicator.textContent = `Set ${npcName}'s emotion to ${emotion}`;
                indicator.style.display = 'block';
                indicator.style.background = emotions[emotion].color;
                
                // Update emotion
                setEmotion(npcName, emotion, 60);
                
                // Add to dialog
                IntegratedUIManager.addMessage(`Larry: *Tries to make ${npcName} feel ${emotion}*`, 'player');
                setTimeout(() => {
                    const response = getEmotionResponse(npcName, 'compliment');
                    IntegratedUIManager.addMessage(`${npcName}: ${response}`, 'npc');
                    
                    // Update mood based on emotion
                    const modifier = getEmotionModifier(npcName, 'mood');
                    const npc = IntegratedGameState.getNPC(npcName);
                    if (npc) {
                        const moodChange = emotion === 'joy' ? 15 : emotion === 'anger' ? -10 : 5;
                        IntegratedGameState.updateNPC(npcName, {
                            baseMood: Math.max(0, Math.min(100, npc.baseMood + moodChange * modifier))
                        });
                    }
                    
                    // Hide indicator after delay
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 2000);
                }, 500);
                
                // Update all emotion segments
                segments.forEach(s => s.classList.remove('active'));
                segment.classList.add('active');
            });
        });

        // Toggle emotion wheel
        document.getElementById('emotion-wheel-toggle').addEventListener('click', () => {
            wheel.style.display = wheel.style.display === 'none' ? 'flex' : 'none';
        });
    };

    return {
        getEmotion,
        setEmotion,
        influenceEmotion,
        getEmotionModifier,
        getEmotionResponse,
        initializeEmotionWheel,
        updateEmotionDisplay
    };
})();

// ===== STORY ENGINE =====
const StoryEngine = (() => {
    const storyBranches = {
        Eve: [
            { level: 0, title: "First Meeting", description: "Meet Eve at the bar", unlocked: true },
            { level: 20, title: "Getting to Know", description: "Learn about Eve's past", unlocked: false },
            { level: 40, title: "Opening Up", description: "Eve shares her dreams", unlocked: false },
            { level: 60, title: "Deep Connection", description: "Share intimate moments", unlocked: false },
            { level: 80, title: "True Love", description: "Commit to each other", unlocked: false }
        ],
        Jessica: [
            { level: 0, title: "The Flirt", description: "Meet Jessica at the bar", unlocked: true },
            { level: 25, title: "Dance Partner", description: "Dance with Jessica", unlocked: false },
            { level: 50, title: "Night Out", description: "Experience the nightlife together", unlocked: false },
            { level: 75, title: "Unexpected Feelings", description: "Develop deeper connection", unlocked: false }
        ],
        Danielle: [
            { level: 0, title: "The Receptionist", description: "Meet Danielle at the hotel", unlocked: true },
            { level: 30, title: "Hotel Secrets", description: "Learn hotel secrets", unlocked: false },
            { level: 60, title: "Romantic Evening", description: "Spend evening together", unlocked: false }
        ],
        Ashley: [
            { level: 0, title: "Beach Encounter", description: "Meet Ashley at the beach", unlocked: true },
            { level: 35, title: "Surf Lessons", description: "Learn to surf together", unlocked: false },
            { level: 70, title: "Sunset Romance", description: "Watch sunset together", unlocked: false }
        ],
        Nicole: [
            { level: 0, title: "Casino Queen", description: "Meet Nicole at the casino", unlocked: true },
            { level: 40, title: "High Stakes", description: "Play high stakes games", unlocked: false },
            { level: 80, title: "Mystery Solved", description: "Learn Nicole's secret", unlocked: false }
        ]
    };

    const currentStory = {};

    const checkStoryProgress = (npcName, relationshipLevel) => {
        const branches = storyBranches[npcName] || [];
        const unlockedBranches = branches.filter(branch => relationshipLevel >= branch.level);
        
        // Unlock new branches
        unlockedBranches.forEach(branch => {
            if (!branch.unlocked) {
                branch.unlocked = true;
                IntegratedUIManager.showNotification(`üìñ New Story Branch Unlocked: ${branch.title} with ${npcName}!`, 'success');
                
                // Add story comment
                IntegratedGameState.addComment({
                    npc: npcName,
                    text: `I feel like I can share more with you now...`,
                    time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    adult: false
                });
                IntegratedUIManager.renderComments();
            }
        });
        
        return unlockedBranches;
    };

    const generateStoryDialog = (npcName, storyLevel) => {
        const stories = {
            Eve: {
                20: "You know, I wasn't always this confident. I used to be quite shy actually...",
                40: "Sometimes I wonder what I'm doing with my life. There has to be more than this, right?",
                60: "I've never told anyone this, but... I'm actually afraid of being alone.",
                80: "You make me feel things I haven't felt in a long time. Maybe we're meant to be..."
            },
            Jessica: {
                25: "I love dancing! It's like telling a story with your body, you know?",
                50: "The nightlife can be exhausting sometimes. It's nice to have someone real to talk to.",
                75: "You're different from the other guys here. You actually listen to me."
            },
            Danielle: {
                30: "Working at the hotel, you see all kinds of people. Some stories are quite romantic.",
                60: "There's a secret rooftop garden here. Not many people know about it..."
            },
            Ashley: {
                35: "Surfing taught me to go with the flow. You can't fight the waves, you know?",
                70: "Sunsets here are magical. They remind me that every ending can be beautiful."
            },
            Nicole: {
                40: "In poker, it's not about the cards you're dealt, but how you play them.",
                80: "I have a secret... this isn't my real name. But you can call me whatever you like."
            }
        };
        
        return stories[npcName]?.[storyLevel] || "I'm enjoying our conversation.";
    };

    const renderStoryProgress = () => {
        const container = document.getElementById('story-progress-content');
        if (!container) return;
        
        container.innerHTML = '';
        const state = IntegratedGameState.getState();
        const npcs = IntegratedGameState.getNPCs();
        
        Object.keys(storyBranches).forEach(npcName => {
            const npc = npcs[npcName];
            if (npc && npc.relationship > 0) {
                const branches = storyBranches[npcName];
                const unlockedCount = branches.filter(b => b.unlocked).length;
                const totalBranches = branches.length;
                
                const storySection = document.createElement('div');
                storySection.className = 'story-progress';
                
                let storyHTML = `<h4>${npcName}'s Story (${unlockedCount}/${totalBranches})</h4>`;
                branches.forEach(branch => {
                    const status = branch.unlocked ? 'unlocked' : 'locked';
                    const icon = branch.unlocked ? '‚úÖ' : 'üîí';
                    storyHTML += `
                        <div class="story-milestone ${status}">
                            <span>${icon}</span>
                            <div>
                                <strong>${branch.title}</strong><br>
                                <small>${branch.description} (Level ${branch.level})</small>
                            </div>
                        </div>
                    `;
                });
                
                storySection.innerHTML = storyHTML;
                container.appendChild(storySection);
            }
        });
        
        if (container.children.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary)">No story progress yet. Build relationships to unlock stories!</div>';
        }
    };

    return {
        checkStoryProgress,
        generateStoryDialog,
        renderStoryProgress
    };
})();

// ===== ACHIEVEMENT SYSTEM =====
const AchievementSystem = (() => {
    const achievements = {
        first_meeting: { id: 'first_meeting', name: 'First Contact', description: 'Talk to your first NPC', icon: 'üëã', unlocked: false },
        social_butterfly: { id: 'social_butterfly', name: 'Social Butterfly', description: 'Talk to all 5 main NPCs', icon: 'ü¶ã', unlocked: false },
        romantic: { id: 'romantic', name: 'Romantic', description: 'Reach relationship 50 with any NPC', icon: 'üíù', unlocked: false },
        player: { id: 'player', name: 'Player', description: 'Have 3 NPCs at relationship 30+', icon: 'üéÆ', unlocked: false },
        collector: { id: 'collector', name: 'Collector', description: 'Collect 10 different items', icon: 'üéí', unlocked: false },
        rich: { id: 'rich', name: 'Rich', description: 'Reach 1000 score', icon: 'üí∞', unlocked: false },
        perfect_romance: { id: 'perfect_romance', name: 'Perfect Romance', description: 'Reach 100 relationship with any NPC', icon: 'üíñ', unlocked: false },
        multi_dater: { id: 'multi_dater', name: 'Multi-Dater', description: 'Go on dates with 3 different NPCs', icon: 'üìÖ', unlocked: false },
        story_master: { id: 'story_master', name: 'Story Master', description: 'Unlock all story branches for one NPC', icon: 'üìñ', unlocked: false },
        emotion_master: { id: 'emotion_master', name: 'Emotion Master', description: 'Experience all 8 emotions with NPCs', icon: 'üí≠', unlocked: false }
    };

    const unlockedAchievements = new Set();
    const achievementCallbacks = {};

    const checkAchievement = (achievementId) => {
        const achievement = achievements[achievementId];
        if (!achievement || achievement.unlocked) return;

        const state = IntegratedGameState.getState();
        const npcs = IntegratedGameState.getNPCs();
        
        let shouldUnlock = false;
        
        switch(achievementId) {
            case 'first_meeting':
                shouldUnlock = Object.values(npcs).some(npc => npc.relationship > 0);
                break;
            case 'social_butterfly':
                const mainNPCs = ['Eve', 'Jessica', 'Danielle', 'Ashley', 'Nicole'];
                shouldUnlock = mainNPCs.every(name => npcs[name]?.relationship > 0);
                break;
            case 'romantic':
                shouldUnlock = Object.values(npcs).some(npc => npc.relationship >= 50);
                break;
            case 'player':
                shouldUnlock = Object.values(npcs).filter(npc => npc.relationship >= 30).length >= 3;
                break;
            case 'collector':
                shouldUnlock = state.inventory.length >= 10;
                break;
            case 'rich':
                shouldUnlock = state.score >= 1000;
                break;
            case 'perfect_romance':
                shouldUnlock = Object.values(npcs).some(npc => npc.relationship >= 100);
                break;
            case 'multi_dater':
                // Check scheduled dates
                shouldUnlock = state.scheduledDates.filter(date => date.completed).length >= 3;
                break;
            case 'story_master':
                // Simplified check - if any NPC has high relationship
                shouldUnlock = Object.values(npcs).some(npc => npc.relationship >= 80);
                break;
            case 'emotion_master':
                // Simplified check
                shouldUnlock = state.enhancedMode && state.score > 500;
                break;
        }

        if (shouldUnlock) {
            unlockAchievement(achievementId);
        }
    };

    const unlockAchievement = (achievementId) => {
        const achievement = achievements[achievementId];
        if (!achievement || achievement.unlocked) return;

        achievement.unlocked = true;
        unlockedAchievements.add(achievementId);
        
        IntegratedUIManager.showNotification(`üèÜ Achievement Unlocked: ${achievement.name}! +100 points`, 'success');
        IntegratedGameState.setState({ score: IntegratedGameState.getState().score + 100 });
        
        // Trigger callback if exists
        if (achievementCallbacks[achievementId]) {
            achievementCallbacks[achievementId]();
        }
        
        renderAchievements();
    };

    const renderAchievements = () => {
        const container = document.getElementById('achievements-grid');
        if (!container) return;
        
        container.innerHTML = '';
        Object.values(achievements).forEach(achievement => {
            const achievementEl = document.createElement('div');
            achievementEl.className = `achievement ${achievement.unlocked ? 'unlocked' : 'locked'}`;
            achievementEl.title = `${achievement.name}: ${achievement.description}`;
            
            achievementEl.innerHTML = `
                <div style="font-size: 2rem;">${achievement.icon}</div>
                <div style="font-size: 0.7rem; margin-top: 5px;">${achievement.name}</div>
            `;
            
            container.appendChild(achievementEl);
        });
    };

    const checkAllAchievements = () => {
        Object.keys(achievements).forEach(checkAchievement);
    };

    return {
        checkAchievement,
        unlockAchievement,
        renderAchievements,
        checkAllAchievements
    };
})();

// ===== ANALYTICS DASHBOARD =====
const AnalyticsSystem = (() => {
    const relationshipHistory = new Map();
    
    const recordRelationshipChange = (npcName, oldValue, newValue) => {
        if (!relationshipHistory.has(npcName)) {
            relationshipHistory.set(npcName, []);
        }
        
        const history = relationshipHistory.get(npcName);
        history.push({
            value: newValue,
            timestamp: Date.now(),
            location: IntegratedGameState.getState().currentLocation
        });
        
        // Keep only last 20 entries
        if (history.length > 20) {
            history.shift();
        }
    };
    
    const renderRelationshipGraph = () => {
        const container = document.getElementById('relationship-graph');
        if (!container) return;
        
        container.innerHTML = '';
        const npcs = IntegratedGameState.getNPCs();
        const activeNPCs = Object.values(npcs).filter(npc => npc.relationship > 0);
        
        if (activeNPCs.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary)">No relationship data yet. Start talking to NPCs!</div>';
            return;
        }
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        activeNPCs.forEach((npc, npcIndex) => {
            const lineContainer = document.createElement('div');
            lineContainer.style.position = 'absolute';
            lineContainer.style.width = '100%';
            lineContainer.style.height = '100%';
            container.appendChild(lineContainer);
            
            const history = relationshipHistory.get(npc.name) || [{ value: npc.relationship }];
            const points = history.map((h, i) => ({
                x: (i / (history.length - 1 || 1)) * width,
                y: height - (h.value / 100) * height
            }));
            
            for (let i = 1; i < points.length; i++) {
                const line = document.createElement('div');
                line.className = 'graph-line';
                line.style.position = 'absolute';
                line.style.left = `${points[i-1].x}px`;
                line.style.top = `${points[i-1].y}px`;
                line.style.width = `${Math.sqrt(Math.pow(points[i].x - points[i-1].x, 2) + Math.pow(points[i].y - points[i-1].y, 2))}px`;
                line.style.height = '2px';
                line.style.background = npc.color || 'var(--primary)';
                line.style.transformOrigin = '0 0';
                line.style.transform = `rotate(${Math.atan2(points[i].y - points[i-1].y, points[i].x - points[i-1].x)}rad)`;
                lineContainer.appendChild(line);
            }
        });
    };
    
    const getAnalyticsData = () => {
        const npcs = IntegratedGameState.getNPCs();
        const data = {
            totalInteractions: IntegratedGameState.getMessages().length,
            npcRelationships: {},
            timePlayed: IntegratedGameState.getState().time,
            itemsCollected: IntegratedGameState.getState().inventory.length,
            questsCompleted: IntegratedGameState.getState().questsCompleted
        };
        
        Object.keys(npcs).forEach(npcName => {
            const npc = npcs[npcName];
            if (npc && npc.relationship > 0) {
                data.npcRelationships[npcName] = {
                    relationship: npc.relationship,
                    mood: npc.baseMood,
                    intimacy: npc.intimacy || 0
                };
            }
        });
        
        return data;
    };
    
    return {
        recordRelationshipChange,
        renderRelationshipGraph,
        getAnalyticsData
    };
})();

// ===== MINI-GAME SYSTEM =====
const MiniGameSystem = (() => {
    const games = {
        poker: {
            name: 'Poker',
            minBet: 50,
            maxBet: 500,
            setup: (container) => {
                container.innerHTML = `
                    <div class="poker-table" id="poker-table">
                        <div class="poker-card" data-card="1">üÉè</div>
                        <div class="poker-card" data-card="2">üÉè</div>
                        <div class="poker-card" data-card="3">üÉè</div>
                        <div class="poker-card" data-card="4">üÉè</div>
                        <div class="poker-card" data-card="5">üÉè</div>
                    </div>
                    <div style="text-align: center; margin: 15px 0;">
                        <div>Your Score: <span id="poker-score">0</span></div>
                        <div>NPC Score: <span id="npc-poker-score">0</span></div>
                    </div>
                `;
            },
            play: () => {
                const cards = document.querySelectorAll('.poker-card');
                const playerScoreEl = document.getElementById('poker-score');
                const npcScoreEl = document.getElementById('npc-poker-score');
                
                // Deal cards
                cards.forEach(card => {
                    const suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è'];
                    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    const suit = suits[Math.floor(Math.random() * suits.length)];
                    const value = values[Math.floor(Math.random() * values.length)];
                    
                    card.textContent = suit === '‚ô•Ô∏è' || suit === '‚ô¶Ô∏è' ? `üü•${value}` : `‚¨õ${value}`;
                    card.style.background = suit === '‚ô•Ô∏è' || suit === '‚ô¶Ô∏è' ? '#ff6b6b' : '#2c3e50';
                    card.style.color = 'white';
                });
                
                // Calculate scores (simplified)
                const playerScore = Math.floor(Math.random() * 50) + 25;
                const npcScore = Math.floor(Math.random() * 50) + 20;
                
                playerScoreEl.textContent = playerScore;
                npcScoreEl.textContent = npcScore;
                
                // Determine winner
                setTimeout(() => {
                    const state = IntegratedGameState.getState();
                    if (playerScore > npcScore) {
                        const winnings = 100;
                        IntegratedGameState.setState({ score: state.score + winnings });
                        IntegratedUIManager.showNotification(`üéâ You won $${winnings} at poker!`, 'success');
                    } else {
                        const loss = 50;
                        if (state.score >= loss) {
                            IntegratedGameState.setState({ score: state.score - loss });
                            IntegratedUIManager.showNotification(`üòî Lost $${loss} at poker.`, 'warning');
                        }
                    }
                    IntegratedUIManager.updateStats();
                }, 1000);
            }
        },
        dancing: {
            name: 'Dancing',
            setup: (container) => {
                container.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 4rem; margin: 20px 0;">üíÉ</div>
                        <div>Match the rhythm to impress your partner!</div>
                        <div style="margin: 20px 0;">
                            <button class="btn" id="dance-up">‚Üë</button>
                            <button class="btn" id="dance-down">‚Üì</button>
                            <button class="btn" id="dance-left">‚Üê</button>
                            <button class="btn" id="dance-right">‚Üí</button>
                        </div>
                        <div>Score: <span id="dance-score">0</span></div>
                    </div>
                `;
            },
            play: () => {
                // Simplified dancing game
                const scoreEl = document.getElementById('dance-score');
                let score = 0;
                
                const danceButtons = ['dance-up', 'dance-down', 'dance-left', 'dance-right'];
                danceButtons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) {
                        btn.addEventListener('click', () => {
                            score += 10;
                            scoreEl.textContent = score;
                            
                            // Add random NPC reaction
                            const reactions = ['Nice moves!', 'You can dance!', 'Impressive!', 'Let me try!'];
                            const reaction = reactions[Math.floor(Math.random() * reactions.length)];
                            
                            // Update relationship based on score
                            if (score >= 50) {
                                const state = IntegratedGameState.getState();
                                const npc = IntegratedGameState.getNPC(state.currentNPC);
                                if (npc) {
                                    IntegratedGameState.updateNPC(state.currentNPC, {
                                        relationship: npc.relationship + 5,
                                        baseMood: Math.min(100, npc.baseMood + 10)
                                    });
                                    IntegratedUIManager.showNotification(`üíÉ ${reaction} Relationship +5!`, 'success');
                                    IntegratedUIManager.updateStats();
                                }
                            }
                        });
                    }
                });
            }
        }
    };
    
    const startMiniGame = (gameName) => {
        const game = games[gameName];
        if (!game) return;
        
        const panel = document.getElementById('mini-game-panel');
        const title = document.getElementById('mini-game-title');
        const content = document.getElementById('poker-table')?.parentElement || panel;
        
        title.textContent = game.name;
        game.setup(content);
        panel.style.display = 'block';
        
        // Setup game controls
        const dealBtn = document.getElementById('deal-poker');
        const foldBtn = document.getElementById('fold-poker');
        const betBtn = document.getElementById('bet-poker');
        const closeBtn = document.getElementById('close-mini-game');
        
        if (dealBtn) dealBtn.onclick = () => game.play();
        if (foldBtn) foldBtn.onclick = () => {
            IntegratedUIManager.showNotification('Folded! Better luck next time.', 'warning');
            panel.style.display = 'none';
        };
        if (betBtn) betBtn.onclick = () => {
            const state = IntegratedGameState.getState();
            if (state.score >= 50) {
                IntegratedGameState.setState({ score: state.score - 50 });
                game.play();
                IntegratedUIManager.updateStats();
            } else {
                IntegratedUIManager.showNotification('Not enough money to bet!', 'error');
            }
        };
        if (closeBtn) closeBtn.onclick = () => {
            panel.style.display = 'none';
        };
    };
    
    return {
        startMiniGame
    };
})();

// ===== INTEGRATED GAME STATE (Enhanced) =====
const IntegratedGameState = (() => {
    // Original state structure
    let state = {
        ageVerified: false,
        adultMode: false,
        score: 0,
        time: 0,
        relationship: 15,
        mood: 50,
        intimacy: 0,
        progress: 0,
        currentLocation: 'bar',
        currentQuest: 0,
        questsCompleted: 0,
        inventory: ['money', 'phone', 'carKeys', 'sunglasses'],
        selectedItem: null,
        aiMode: true,
        // Enhanced features
        enhancedMode: false,
        currentNPC: 'Eve',
        activeDate: null,
        scheduledDates: [],
        unlockedEndings: [],
        jealousyLevel: 0,
        // Item respawn tracking
        collectedItems: {},
        respawnTimers: {},
        // NEW: Condom tracking system
        condomCount: 3, // Start with 3 condoms
        lastCondomRestock: 0,
        condomRestockTimer: null,
        canRestockCondoms: true,
        // NEW: Emotion tracking
        emotionMemory: {},
        // NEW: Story progress tracking
        storyProgress: {},
        // NEW: Achievement tracking
        achievements: [],
        // NEW: Analytics data
        analytics: { interactions: 0, locationsVisited: ['bar'] }
    };

    // Original locations with enhanced data
    const locations = [
        { 
            id: 'bar', 
            name: 'Le Bar de l\'Amour', 
            items: ['briefcase', 'drink', 'key', 'wine', 'napkin'],
            npcs: ['Eve', 'Jessica', 'Bartender'],
            adultAvailable: true,
            dateAvailable: true,
            dateBackground: 'linear-gradient(135deg, #2c3e50, #34495e)',
            // Special items that should respawn quickly (like drinks)
            respawnItems: ['drink', 'wine'],
            respawnTime: 30000, // 30 seconds for drinks
            // NEW: Can purchase condoms here
            canBuyCondoms: true,
            condomPrice: 50
        },
        { 
            id: 'hotel', 
            name: 'Hotel Lobby', 
            items: ['flowers', 'perfume', 'roomKey', 'champagne'],
            npcs: ['Danielle', 'Receptionist', 'Maid'],
            adultAvailable: true,
            dateAvailable: true,
            dateBackground: 'linear-gradient(135deg, #3498db, #2980b9)',
            respawnItems: [],
            respawnTime: 60000, // 1 minute for other items
            canBuyCondoms: true,
            condomPrice: 50
        },
        { 
            id: 'beach', 
            name: 'Sunset Beach', 
            items: ['shell', 'towel', 'sunscreen', 'cocktail'],
            npcs: ['Ashley', 'Lifeguard', 'BikiniGirl'],
            adultAvailable: false,
            dateAvailable: true,
            dateBackground: 'linear-gradient(135deg, #f1c40f, #f39c12)',
            respawnItems: ['cocktail'],
            respawnTime: 30000,
            canBuyCondoms: false,
            condomPrice: 0
        },
        { 
            id: 'casino', 
            name: 'Golden Casino', 
            items: ['chips', 'dice', 'cigar', 'whiskey'],
            npcs: ['Nicole', 'Dealer', 'RichMan'],
            adultAvailable: true,
            dateAvailable: true,
            dateBackground: 'linear-gradient(135deg, #e74c3c, #c0392b)',
            respawnItems: ['whiskey', 'cigar'],
            respawnTime: 30000,
            canBuyCondoms: true,
            condomPrice: 50
        },
        { 
            id: 'hotelRoom', 
            name: 'Hotel Suite', 
            items: ['robe', 'candle', 'chocolate', 'lube'],
            npcs: ['Eve'],
            adultAvailable: true,
            locked: true,
            dateAvailable: false,
            dateBackground: 'linear-gradient(135deg, #9b59b6, #8e44ad)',
            respawnItems: [],
            respawnTime: 0, // Special items don't respawn
            canBuyCondoms: false,
            condomPrice: 0
        }
    ];

    // Combined items (original + enhanced)
    const items = {
        briefcase: { emoji: 'üíº', name: 'Mystery Briefcase', adult: false, consumable: false },
        drink: { emoji: 'üç∏', name: 'Exotic Cocktail', adult: false, consumable: true },
        key: { emoji: 'üîë', name: 'Golden Key', adult: false, consumable: false },
        money: { emoji: 'üíµ', name: 'Cash', adult: false, consumable: false },
        phone: { emoji: 'üì±', name: 'Smartphone', adult: false, consumable: false },
        carKeys: { emoji: 'üöó', name: 'Car Keys', adult: false, consumable: false },
        sunglasses: { emoji: 'üï∂Ô∏è', name: 'Sunglasses', adult: false, consumable: false },
        flowers: { emoji: 'üíê', name: 'Flowers', adult: false, consumable: true },
        perfume: { emoji: 'üß¥', name: 'Perfume', adult: false, consumable: true },
        shell: { emoji: 'üêö', name: 'Seashell', adult: false, consumable: false },
        towel: { emoji: 'üèñÔ∏è', name: 'Beach Towel', adult: false, consumable: false },
        chips: { emoji: 'ü™ô', name: 'Poker Chips', adult: false, consumable: true },
        dice: { emoji: 'üé≤', name: 'Lucky Dice', adult: false, consumable: false },
        condom: { emoji: 'üíã', name: 'Protection', adult: true, consumable: true, restockable: true },
        wine: { emoji: 'üç∑', name: 'Romantic Wine', adult: true, consumable: true },
        roomKey: { emoji: 'üè®', name: 'Room Key', adult: true, consumable: false },
        champagne: { emoji: 'üçæ', name: 'Champagne', adult: true, consumable: true },
        sunscreen: { emoji: 'üß¥', name: 'Sunscreen', adult: true, consumable: true },
        cigar: { emoji: 'üö¨', name: 'Cigar', adult: true, consumable: true },
        whiskey: { emoji: 'ü•É', name: 'Whiskey', adult: true, consumable: true },
        robe: { emoji: 'üëò', name: 'Silk Robe', adult: true, consumable: false },
        candle: { emoji: 'üïØÔ∏è', name: 'Scented Candle', adult: true, consumable: true },
        chocolate: { emoji: 'üç´', name: 'Chocolate', adult: true, consumable: true },
        lube: { emoji: 'üíß', name: 'Massage Oil', adult: true, consumable: true },
        napkin: { emoji: 'üßª', name: 'Napkin', adult: false, consumable: true },
        cocktail: { emoji: 'üçπ', name: 'Beach Cocktail', adult: true, consumable: true },
        ticket: { emoji: 'üé´', name: 'Concert Ticket', adult: false, consumable: false }
    };

    // Enhanced NPC data integrated with original
    const npcs = {
        Eve: {
            id: 'eve',
            name: 'Eve',
            emoji: 'üë©',
            color: 'var(--eve)',
            locations: ['bar', 'hotelRoom'],
            baseMood: 50,
            relationship: 15,
            intimacy: 0,
            adultTolerance: 7,
            personality: 'confident',
            storyProgress: 0,
            giftPreferences: ['wine', 'flowers', 'chocolate'],
            jealousyLevel: 0,
            quests: [
                { id: 'eve1', name: "Get Eve's Attention", completed: false, progress: 0 },
                { id: 'eve2', name: "Romantic Evening", completed: false, progress: 0 }
            ],
            endings: [],
            // NEW: Emotion data
            currentEmotion: 'anticipation',
            emotionIntensity: 50,
            emotionalMemory: []
        },
        Jessica: {
            id: 'jessica',
            name: 'Jessica',
            emoji: 'üíÉ',
            color: 'var(--jessica)',
            locations: ['bar'],
            baseMood: 60,
            relationship: 0,
            intimacy: 0,
            adultTolerance: 6,
            personality: 'flirtatious',
            storyProgress: 0,
            giftPreferences: ['champagne', 'perfume', 'cigar'],
            jealousyLevel: 0,
            quests: [
                { id: 'jess1', name: "Meet Jessica", completed: false, progress: 0 }
            ],
            endings: [],
            currentEmotion: 'joy',
            emotionIntensity: 60
        },
        Danielle: {
            id: 'danielle',
            name: 'Danielle',
            emoji: 'üë∞',
            color: 'var(--danielle)',
            locations: ['hotel'],
            baseMood: 55,
            relationship: 0,
            intimacy: 0,
            adultTolerance: 7,
            personality: 'romantic',
            storyProgress: 0,
            giftPreferences: ['flowers', 'chocolate', 'candle'],
            jealousyLevel: 0,
            quests: [
                { id: 'dan1', name: "Help Danielle", completed: false, progress: 0 }
            ],
            endings: [],
            currentEmotion: 'trust',
            emotionIntensity: 55
        },
        Ashley: {
            id: 'ashley',
            name: 'Ashley',
            emoji: 'üèñÔ∏è',
            color: 'var(--ashley)',
            locations: ['beach'],
            baseMood: 65,
            relationship: 0,
            intimacy: 0,
            adultTolerance: 8,
            personality: 'fun',
            storyProgress: 0,
            giftPreferences: ['sunscreen', 'cocktail', 'towel'],
            jealousyLevel: 0,
            quests: [
                { id: 'ash1', name: "Beach Fun", completed: false, progress: 0 }
            ],
            endings: [],
            currentEmotion: 'joy',
            emotionIntensity: 65
        },
        Nicole: {
            id: 'nicole',
            name: 'Nicole',
            emoji: 'üé∞',
            color: 'var(--nicole)',
            locations: ['casino'],
            baseMood: 60,
            relationship: 0,
            intimacy: 0,
            adultTolerance: 7,
            personality: 'mysterious',
            storyProgress: 0,
            giftPreferences: ['whiskey', 'chips', 'dice'],
            jealousyLevel: 0,
            quests: [
                { id: 'nic1', name: "Win Nicole's Trust", completed: false, progress: 0 }
            ],
            endings: [],
            currentEmotion: 'anticipation',
            emotionIntensity: 60
        },
        // Original NPCs for backward compatibility
        Bartender: { mood: 40, relationship: 5, adultTolerance: 8 },
        Receptionist: { mood: 30, relationship: 0, adultTolerance: 5 },
        Maid: { mood: 50, relationship: 0, adultTolerance: 6 },
        Lifeguard: { mood: 40, relationship: 0, adultTolerance: 4 },
        BikiniGirl: { mood: 70, relationship: 0, adultTolerance: 9 },
        Dealer: { mood: 45, relationship: 0, adultTolerance: 7 },
        RichMan: { mood: 30, relationship: 0, adultTolerance: 8 }
    };

    // Original quests with enhanced quests
    const quests = [
        { 
            id: 1, 
            name: "Get Eve's attention", 
            description: "Make Eve notice you by saying something interesting", 
            progress: 0, 
            completed: false, 
            reward: 100,
            objective: "Talk to Eve using interesting conversation options"
        },
        { 
            id: 2, 
            name: "Buy a drink", 
            description: "Get a drink for Eve to break the ice", 
            progress: 0, 
            completed: false, 
            reward: 150,
            objective: "Use the 'Offer a drink' dialog option"
        },
        { 
            id: 3, 
            name: "Find flowers", 
            description: "Get flowers to impress Eve", 
            progress: 0, 
            completed: false, 
            reward: 200,
            objective: "Collect flowers from the Hotel Lobby"
        },
        { 
            id: 4, 
            name: "Get perfume", 
            description: "Find Eve's favorite perfume", 
            progress: 0, 
            completed: false, 
            reward: 250,
            objective: "Collect perfume from the Hotel Lobby"
        },
        { 
            id: 5, 
            name: "Get a hotel room", 
            description: "Secure a room for the night", 
            progress: 0, 
            completed: false, 
            reward: 300, 
            adult: true,
            objective: "Collect the room key and build relationship to 70+"
        },
        { 
            id: 6, 
            name: "Romantic evening", 
            description: "Spend intimate time with Eve", 
            progress: 0, 
            completed: false, 
            reward: 500, 
            adult: true,
            objective: "Use adult items and flirt to increase intimacy"
        },
        // Enhanced quests
        { id: 7, name: "Meet All NPCs", description: "Encounter all romanceable NPCs", progress: 0, completed: false, reward: 200, enhanced: true },
        { id: 8, name: "Multiple Dates", description: "Go on dates with 3 different NPCs", progress: 0, completed: false, reward: 300, adult: true, enhanced: true },
        { id: 9, name: "True Love", description: "Reach 100 relationship with one NPC", progress: 0, completed: false, reward: 500, enhanced: true },
        { id: 10, name: "Player", description: "Reach 50+ relationship with 4 NPCs", progress: 0, completed: false, reward: 400, adult: true, enhanced: true },
        // NEW: Story quests
        { id: 11, name: "Story Teller", description: "Unlock 3 story branches", progress: 0, completed: false, reward: 300, enhanced: true },
        { id: 12, name: "Emotion Master", description: "Experience 5 different emotions", progress: 0, completed: false, reward: 250, enhanced: true }
    ];

    const npcDialogs = {
        Eve: {
            greetings: [
                "Another night, another hopeful romantic. Make it interesting.",
                "You again? I'm starting to get used to seeing you.",
                "Well hello there. What's on your mind tonight?"
            ],
            compliments: [
                "Flattery will get you... well, maybe somewhere.",
                "You're not like the others. I'll give you that.",
                "That was actually quite charming!"
            ],
            storyHooks: [
                "You know, I wasn't always this confident...",
                "Sometimes I wonder what I'm doing here...",
                "Tell me something real about yourself."
            ]
        },
        Jessica: {
            greetings: [
                "Hey handsome! Come here often?",
                "Ooh, I like your style! Wanna dance?",
                "You look like you know how to have fun!"
            ],
            compliments: [
                "Smooth! I like a man who knows what he wants.",
                "You're making me blush!",
                "Keep talking like that and you might just get lucky!"
            ]
        },
        Danielle: {
            greetings: [
                "Hello... you seem different from the usual guests.",
                "It's a beautiful evening, isn't it?",
                "I love working here, there's always interesting people."
            ],
            compliments: [
                "That's very sweet of you to say.",
                "You have a kind way with words.",
                "Not many people notice the little things."
            ]
        },
        Ashley: {
            greetings: [
                "Hey! Enjoying the beach?",
                "Great day for some sun!",
                "You look like you could use some fun!"
            ],
            compliments: [
                "Aw, thanks! You're sweet!",
                "That's nice of you to say!",
                "You're making me smile!"
            ]
        },
        Nicole: {
            greetings: [
                "Interesting... I haven't seen you here before.",
                "Care to try your luck?",
                "You have an interesting aura about you."
            ],
            compliments: [
                "Interesting observation...",
                "You're quite perceptive.",
                "Not many people notice that."
            ]
        }
    };

    const npcComments = [];
    const messages = [];

    // Helper functions
    const getSelectedItem = () => state.selectedItem;
    const setSelectedItem = (itemId) => { state.selectedItem = itemId; };

    // Enhanced relationship management
    const getActiveRelationships = () => {
        const enhancedNPCs = ['Eve', 'Jessica', 'Danielle', 'Ashley', 'Nicole'];
        return enhancedNPCs
            .map(name => npcs[name])
            .filter(npc => npc && npc.relationship > 0)
            .sort((a, b) => b.relationship - a.relationship);
    };

    const getAvailableNPCs = () => {
        const currentLocation = locations.find(loc => loc.id === state.currentLocation);
        const enhancedNPCs = ['Eve', 'Jessica', 'Danielle', 'Ashley', 'Nicole'];
        return enhancedNPCs
            .map(name => npcs[name])
            .filter(npc => 
                npc && 
                currentLocation?.npcs.includes(npc.name) && 
                (state.adultMode || npc.adultTolerance >= 5)
            );
    };

    const updateJealousy = () => {
        if (!state.enhancedMode) return;
        
        const activeNPCs = getActiveRelationships();
        if (activeNPCs.length > 1) {
            state.jealousyLevel = Math.min(100, activeNPCs.length * 15);
            
            activeNPCs.forEach(npc => {
                if (npc.name !== state.currentNPC) {
                    npc.jealousyLevel = Math.min(100, (npc.jealousyLevel || 0) + 5);
                }
            });
        } else {
            state.jealousyLevel = 0;
        }
    };

    const scheduleDate = (npcName, locationId, time) => {
        state.scheduledDates.push({
            npc: npcName,
            location: locationId,
            time: time,
            completed: false
        });
        
        if (npcs[npcName]) {
            npcs[npcName].relationship += 10;
            state.relationship = npcs[npcName].relationship;
            
            // Record relationship change for analytics
            AnalyticsSystem.recordRelationshipChange(npcName, npcs[npcName].relationship - 10, npcs[npcName].relationship);
        }
    };

    const unlockEnding = (npcName, endingType) => {
        const endingId = `${npcName}_${endingType}`;
        if (!state.unlockedEndings.includes(endingId)) {
            state.unlockedEndings.push(endingId);
            state.score += 1000;
            
            // Check achievement
            AchievementSystem.checkAchievement('perfect_romance');
            
            return true;
        }
        return false;
    };

    // Item respawn system
    const markItemCollected = (locationId, itemId) => {
        const key = `${locationId}_${itemId}`;
        state.collectedItems[key] = Date.now();
        
        // Update analytics
        state.analytics.itemsCollected = (state.analytics.itemsCollected || 0) + 1;
        
        // Set respawn timer
        const location = locations.find(loc => loc.id === locationId);
        if (location && location.respawnItems.includes(itemId)) {
            const respawnTime = location.respawnTime || 30000;
            clearTimeout(state.respawnTimers[key]);
            
            state.respawnTimers[key] = setTimeout(() => {
                delete state.collectedItems[key];
                IntegratedUIManager.showNotification(`${items[itemId]?.name || 'Item'} has respawned!`);
                IntegratedSceneManager.renderScene();
            }, respawnTime);
        }
    };

    const isItemAvailable = (locationId, itemId) => {
        const key = `${locationId}_${itemId}`;
        return !state.collectedItems[key];
    };

    const getAvailableItems = (locationId) => {
        const location = locations.find(loc => loc.id === locationId);
        if (!location) return [];
        
        return location.items.filter(itemId => isItemAvailable(locationId, itemId));
    };

    // NEW: Condom management system
    const getCondomCount = () => state.condomCount;
    const useCondom = () => {
        if (state.condomCount > 0) {
            state.condomCount--;
            state.lastCondomRestock = Date.now();
            return true;
        }
        return false;
    };
    
    const restockCondom = () => {
        if (state.condomCount < 5) { // Max 5 condoms
            state.condomCount++;
            state.lastCondomRestock = Date.now();
            return state.condomCount;
        }
        return state.condomCount;
    };
    
    const canUseCondom = () => state.condomCount > 0 && state.adultMode;
    const getCondomStatus = () => ({
        count: state.condomCount,
        canRestock: state.canRestockCondoms,
        lastRestock: state.lastCondomRestock
    });
    
    // Auto-restock condoms periodically (every 3 minutes)
    const startCondomRestockSystem = () => {
        // Clear existing timer
        if (state.condomRestockTimer) {
            clearInterval(state.condomRestockTimer);
        }
        
        // Auto-restock every 3 minutes if below max
        state.condomRestockTimer = setInterval(() => {
            if (state.condomCount < 3 && state.canRestockCondoms) {
                state.condomCount++;
                IntegratedUIManager.showNotification(`üîÑ Protection restocked! Now have ${state.condomCount}.`, 'success');
                
                // Update inventory display if needed
                if (IntegratedUIManager.elements.inventoryGrid) {
                    IntegratedInventoryManager.renderInventory();
                }
            }
        }, 180000); // 3 minutes = 180,000ms
    };
    
    const stopCondomRestockSystem = () => {
        if (state.condomRestockTimer) {
            clearInterval(state.condomRestockTimer);
            state.condomRestockTimer = null;
        }
    };

    // NEW: Update NPC relationship with analytics tracking
    const updateNPCRelationship = (npcName, change) => {
        const npc = npcs[npcName];
        if (npc) {
            const oldValue = npc.relationship;
            npc.relationship = Math.max(0, Math.min(100, npc.relationship + change));
            state.relationship = npc.relationship;
            
            // Record for analytics
            AnalyticsSystem.recordRelationshipChange(npcName, oldValue, npc.relationship);
            
            // Check story progress
            StoryEngine.checkStoryProgress(npcName, npc.relationship);
            
            // Check achievements
            AchievementSystem.checkAchievement('romantic');
            if (npc.relationship >= 50) {
                AchievementSystem.checkAchievement('romantic');
            }
            
            // Update jealousy
            updateJealousy();
            
            // Update emotion based on relationship change
            if (change > 0) {
                EmotionSystem.influenceEmotion(npcName, 'joy', change);
            } else if (change < 0) {
                EmotionSystem.influenceEmotion(npcName, 'anger', -change);
            }
        }
    };

    return {
        getState: () => ({ ...state }),
        setState: (newState) => { 
            const oldState = { ...state };
            state = { ...state, ...newState };
            
            // Sync relationship with current NPC
            if (state.currentNPC && npcs[state.currentNPC]) {
                state.relationship = npcs[state.currentNPC].relationship;
            }
            
            // Check achievements on state changes
            if (newState.score !== oldState.score) {
                AchievementSystem.checkAchievement('rich');
            }
            if (newState.inventory && newState.inventory.length !== oldState.inventory?.length) {
                AchievementSystem.checkAchievement('collector');
            }
        },
        
        getSelectedItem,
        setSelectedItem,
        
        getLocations: () => [...locations],
        getLocation: (id) => locations.find(loc => loc.id === id),
        
        getItems: () => ({ ...items }),
        getItem: (id) => items[id],
        
        getNPCs: () => ({ ...npcs }),
        getNPC: (name) => npcs[name],
        updateNPC: (name, updates) => {
            if (npcs[name]) {
                const oldRelationship = npcs[name].relationship;
                npcs[name] = { ...npcs[name], ...updates };
                // Update global relationship if this is current NPC
                if (name === state.currentNPC) {
                    state.relationship = npcs[name].relationship;
                }
                
                // Record relationship changes
                if (updates.relationship !== undefined && updates.relationship !== oldRelationship) {
                    AnalyticsSystem.recordRelationshipChange(name, oldRelationship, updates.relationship);
                }
            }
        },
        updateNPCRelationship,
        
        getQuests: () => [...quests],
        getQuest: (id) => quests.find(q => q.id === id),
        getCurrentQuest: () => quests[state.currentQuest],
        
        getNPCDialogs: (npcName) => npcDialogs[npcName] || npcDialogs.Eve,
        
        getComments: () => [...npcComments],
        addComment: (comment) => {
            npcComments.unshift(comment);
            if (npcComments.length > 6) npcComments.pop();
            
            // Update analytics
            state.analytics.interactions = (state.analytics.interactions || 0) + 1;
        },
        
        getMessages: () => [...messages],
        addMessage: (message) => {
            messages.push(message);
            if (messages.length > 15) messages.shift();
        },
        
        // Enhanced functions
        getActiveRelationships,
        getAvailableNPCs,
        updateJealousy,
        scheduleDate,
        unlockEnding,
        
        // Item respawn system
        markItemCollected,
        isItemAvailable,
        getAvailableItems,
        
        // NEW: Condom management
        getCondomCount,
        useCondom,
        restockCondom,
        canUseCondom,
        getCondomStatus,
        startCondomRestockSystem,
        stopCondomRestockSystem,
        
        // NEW: Analytics
        getAnalytics: () => ({ ...state.analytics }),
        recordLocationVisit: (locationId) => {
            if (!state.analytics.locationsVisited.includes(locationId)) {
                state.analytics.locationsVisited.push(locationId);
            }
        },
        
        // Compatibility function
        getCompatibilityData: () => {
            // For save/load compatibility
            return {
                score: state.score,
                time: state.time,
                relationship: state.relationship,
                mood: state.mood,
                currentLocation: state.currentLocation,
                inventory: state.inventory,
                adultMode: state.adultMode,
                enhancedMode: state.enhancedMode,
                condomCount: state.condomCount
            };
        }
    };
})();

// ===== INTEGRATED UI MANAGER (Enhanced) =====
const IntegratedUIManager = (() => {
    const elements = {};
    let eventListeners = new Map();
    
    const initialize = () => {
        // Cache all DOM elements
        elements.ageGate = document.getElementById('age-gate');
        elements.gameContainer = document.getElementById('game-container');
        elements.loading = document.getElementById('loading');
        elements.loadingText = document.getElementById('loading-text');
        elements.adultIndicator = document.getElementById('adult-indicator');
        elements.enhancedIndicator = document.getElementById('enhanced-mode-indicator');
        elements.scoreValue = document.getElementById('score-value');
        elements.timeValue = document.getElementById('time-value');
        elements.relationshipValue = document.getElementById('relationship-value');
        elements.progressValue = document.getElementById('progress-value');
        elements.npcCount = document.getElementById('npc-count');
        elements.moodLevel = document.getElementById('mood-level');
        elements.locationName = document.getElementById('location-name');
        elements.questTracker = document.getElementById('quest-tracker');
        elements.currentQuest = document.getElementById('current-quest');
        elements.questDescription = document.getElementById('quest-description');
        elements.questBar = document.getElementById('quest-bar');
        elements.itemsContainer = document.getElementById('items-container');
        elements.inventoryGrid = document.getElementById('inventory-grid');
        elements.inventoryCount = document.getElementById('inventory-count');
        elements.dialogContent = document.getElementById('dialog-content');
        elements.dialogOptions = document.getElementById('dialog-options');
        elements.commentsContainer = document.getElementById('comments-container');
        elements.notification = document.getElementById('notification');
        elements.aiToggle = document.getElementById('ai-toggle');
        elements.aiStatus = document.getElementById('ai-status');
        elements.miniMap = document.getElementById('mini-map');
        elements.playerCharacter = document.getElementById('player-character');
        elements.eveCharacter = document.getElementById('eve-character');
        elements.currentNpc = document.getElementById('current-npc');
        elements.useBtn = document.getElementById('use-btn');
        
        // Enhanced elements
        elements.enhancedModeToggle = document.getElementById('enhanced-mode-toggle');
        elements.enhancedModeText = document.getElementById('enhanced-mode-text');
        elements.npcSelectorPanel = document.getElementById('npc-selector-panel');
        elements.npcSelectorGrid = document.getElementById('npc-selector-grid');
        elements.relationshipsPanel = document.getElementById('relationships-panel');
        elements.relationshipsList = document.getElementById('relationships-list');
        elements.currentNpcAvatar = document.getElementById('current-npc-avatar');
        elements.currentNpcName = document.getElementById('current-npc-name');
        elements.currentNpcMood = document.getElementById('current-npc-mood');
        elements.currentNpcRelationship = document.getElementById('current-npc-relationship');
        elements.npcDialogIndicator = document.getElementById('npc-dialog-indicator');
        elements.jealousyIndicator = document.getElementById('jealousy-indicator');
        elements.jealousyText = document.getElementById('jealousy-text');
        elements.dateScheduler = document.getElementById('date-scheduler');
        elements.dateScene = document.getElementById('date-scene');
        elements.endingGallery = document.getElementById('ending-gallery');
        elements.emotionWheel = document.getElementById('emotion-wheel');
        
        // New enhanced panels
        elements.storyEnginePanel = document.getElementById('story-engine-panel');
        elements.achievementsPanel = document.getElementById('achievements-panel');
        elements.analyticsPanel = document.getElementById('analytics-panel');
        elements.miniGamePanel = document.getElementById('mini-game-panel');
        
        // Initialize ARIA attributes
        elements.questBar.setAttribute('aria-valuenow', '0');
        elements.moodLevel.setAttribute('aria-valuenow', '50');
        
        // Initially hide enhanced UI elements
        elements.npcDialogIndicator.style.display = 'none';
        elements.jealousyIndicator.style.display = 'none';
        elements.emotionWheel.style.display = 'none';
        
        // Initialize particle background
        initializeParticleBackground();
    };
    
    const initializeParticleBackground = () => {
        const container = document.getElementById('particle-background');
        if (!container) return;
        
        for (let i = 0; i < 30; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.width = `${Math.random() * 10 + 2}px`;
            particle.style.height = particle.style.width;
            particle.style.background = `rgba(255, 255, 255, ${Math.random() * 0.2 + 0.05})`;
            particle.style.left = `${Math.random() * 100}%`;
            particle.style.top = `${Math.random() * 100}%`;
            particle.style.animationDelay = `${Math.random() * 20}s`;
            particle.style.animationDuration = `${Math.random() * 10 + 15}s`;
            container.appendChild(particle);
        }
    };
    
    const showLoading = (message = 'Loading...') => {
        elements.loadingText.textContent = message;
        elements.loading.style.display = 'flex';
    };
    
    const hideLoading = () => {
        elements.loading.style.display = 'none';
    };
    
    const showNotification = (text, type = '') => {
        elements.notification.textContent = text;
        elements.notification.className = `notification ${type} show`;
        
        if (type === 'adult' || text.includes('Quest Completed') || text.includes('unlocked')) {
            elements.notification.style.animation = 'pulse 0.5s 2';
        }
        
        setTimeout(() => {
            elements.notification.classList.remove('show');
            elements.notification.style.animation = '';
        }, 2000);
    };
    
    const updateStats = () => {
        const state = IntegratedGameState.getState();
        elements.scoreValue.textContent = state.score;
        elements.relationshipValue.textContent = state.relationship;
        elements.progressValue.textContent = `${state.progress}%`;
        elements.moodLevel.style.width = `${state.mood}%`;
        elements.moodLevel.setAttribute('aria-valuenow', state.mood);
        
        // Update mood color
        if (state.mood > 70) {
            elements.moodLevel.style.background = 'linear-gradient(90deg, var(--success), var(--success-dark))';
        } else if (state.mood > 30) {
            elements.moodLevel.style.background = 'linear-gradient(90deg, var(--warning), var(--warning-dark))';
        } else {
            elements.moodLevel.style.background = 'linear-gradient(90deg, var(--danger), var(--danger-dark))';
        }
        
        // Update NPC count if in enhanced mode
        if (state.enhancedMode) {
            const activeNPCs = IntegratedGameState.getActiveRelationships().length;
            const totalEnhancedNPCs = 5; // Eve, Jessica, Danielle, Ashley, Nicole
            elements.npcCount.textContent = `${activeNPCs}/${totalEnhancedNPCs}`;
        }
    };
    
    const updateQuestTracker = () => {
        const currentQuest = IntegratedGameState.getCurrentQuest();
        if (!currentQuest) return;
        
        elements.currentQuest.textContent = currentQuest.name;
        elements.questBar.style.width = `${currentQuest.progress}%`;
        elements.questBar.setAttribute('aria-valuenow', currentQuest.progress);
        elements.questDescription.textContent = currentQuest.description;
        elements.questTracker.style.display = 'block';
        
        // Update quest bar color
        if (currentQuest.progress < 30) {
            elements.questBar.style.background = 'linear-gradient(90deg, var(--danger), var(--danger-dark))';
        } else if (currentQuest.progress < 70) {
            elements.questBar.style.background = 'linear-gradient(90deg, var(--warning), var(--warning-dark))';
        } else {
            elements.questBar.style.background = 'linear-gradient(90deg, var(--success), var(--success-dark))';
        }
    };
    
    const addMessage = (text, sender, adult = false) => {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${sender === 'npc' ? 'npc-message' : 'player-message'} ${adult ? 'adult-message' : ''}`;
        messageElement.textContent = text;
        messageElement.setAttribute('role', 'listitem');
        
        elements.dialogContent.appendChild(messageElement);
        
        // Auto-scroll
        setTimeout(() => {
            elements.dialogContent.scrollTo({
                top: elements.dialogContent.scrollHeight,
                behavior: 'smooth'
            });
        }, 100);
    };
    
    const renderComments = () => {
        elements.commentsContainer.innerHTML = '';
        const comments = IntegratedGameState.getComments();
        
        comments.forEach(comment => {
            const commentElement = document.createElement('div');
            commentElement.className = `comment ${comment.adult ? 'adult-comment' : ''}`;
            commentElement.setAttribute('role', 'listitem');
            
            commentElement.innerHTML = `
                <div class="comment-header">
                    <span>${comment.npc}</span>
                    <span>${comment.time}</span>
                </div>
                <div class="comment-text">${comment.text}</div>
            `;
            
            elements.commentsContainer.appendChild(commentElement);
        });
    };
    
    const toggleEnhancedMode = () => {
        const state = IntegratedGameState.getState();
        const newEnhancedMode = !state.enhancedMode;
        IntegratedGameState.setState({ enhancedMode: newEnhancedMode });
        
        if (newEnhancedMode) {
            elements.enhancedIndicator.style.display = 'block';
            elements.enhancedModeText.textContent = 'Disable Enhanced Mode';
            elements.npcDialogIndicator.style.display = 'flex';
            showNotification('üåü Enhanced Mode Enabled! Multi-NPC features activated.', 'success');
            
            // Initialize emotion system
            EmotionSystem.initializeEmotionWheel();
            EmotionSystem.updateEmotionDisplay(state.currentNPC);
            
            // Only add adult items if adult mode is enabled
            if (state.adultMode) {
                const currentInventory = state.inventory;
                const condomCount = IntegratedGameState.getCondomCount();
                
                // Add condom to inventory if we have any
                if (!currentInventory.includes('condom') && condomCount > 0) {
                    currentInventory.push('condom');
                }
                
                if (!currentInventory.includes('ticket')) {
                    currentInventory.push('ticket');
                }
                IntegratedGameState.setState({ inventory: currentInventory });
            }
            
            // Update UI
            updateCurrentNPC();
            renderNPCSelector();
            renderRelationships();
            IntegratedDialogManager.updateDialogOptions();
        } else {
            elements.enhancedIndicator.style.display = 'none';
            elements.enhancedModeText.textContent = 'Enable Enhanced Mode';
            elements.npcDialogIndicator.style.display = 'none';
            elements.npcSelectorPanel.style.display = 'none';
            elements.relationshipsPanel.style.display = 'none';
            elements.emotionWheel.style.display = 'none';
            showNotification('üì± Basic Mode Enabled. Original gameplay restored.', 'warning');
            
            // Update UI
            updateCurrentNPC();
            IntegratedDialogManager.updateDialogOptions();
        }
        
        // Update inventory display
        renderInventory();
    };
    
    const updateCurrentNPC = () => {
        const state = IntegratedGameState.getState();
        const npc = IntegratedGameState.getNPC(state.currentNPC);
        
        if (npc) {
            elements.currentNpcAvatar.textContent = npc.emoji;
            elements.currentNpcAvatar.style.background = npc.color;
            elements.currentNpcName.textContent = npc.name;
            elements.currentNpcMood.textContent = npc.baseMood;
            elements.currentNpcRelationship.textContent = npc.relationship;
            elements.currentNpc.textContent = npc.name;
            
            // Update emotion display
            EmotionSystem.updateEmotionDisplay(state.currentNPC);
        } else {
            elements.currentNpc.textContent = 'Eve';
        }
    };
    
    const renderNPCSelector = () => {
        elements.npcSelectorGrid.innerHTML = '';
        const state = IntegratedGameState.getState();
        
        // Get NPCs available at current location
        const currentLocation = IntegratedGameState.getLocation(state.currentLocation);
        const enhancedNPCs = ['Eve', 'Jessica', 'Danielle', 'Ashley', 'Nicole'];
        
        // Filter NPCs that are in current location AND are compatible with current mode
        const locationNPCs = enhancedNPCs
            .map(name => IntegratedGameState.getNPC(name))
            .filter(npc => 
                npc && 
                currentLocation?.npcs.includes(npc.name) && 
                (state.adultMode || npc.adultTolerance >= 5)
            );
        
        locationNPCs.forEach(npc => {
            const npcElement = document.createElement('div');
            npcElement.className = `npc-portrait ${npc.id} ${npc.name === state.currentNPC ? 'active' : ''}`;
            
            npcElement.innerHTML = `
                <div class="npc-avatar" style="background: ${npc.color}">${npc.emoji}</div>
                <div class="npc-name">${npc.name}</div>
                <div class="npc-relationship">‚ù§Ô∏è ${npc.relationship}</div>
            `;
            
            npcElement.addEventListener('click', () => {
                IntegratedGameState.setState({ currentNPC: npc.name });
                updateCurrentNPC();
                renderNPCSelector();
                IntegratedDialogManager.updateDialogOptions();
                elements.npcSelectorPanel.style.display = 'none';
                showNotification(`Now talking to ${npc.name}`);
                
                // Update emotion display for new NPC
                EmotionSystem.updateEmotionDisplay(npc.name);
            });
            
            elements.npcSelectorGrid.appendChild(npcElement);
        });
        
        // Show message if no NPCs available
        if (locationNPCs.length === 0) {
            elements.npcSelectorGrid.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary)">No other NPCs available here.</div>';
        }
    };
    
    const renderRelationships = () => {
        elements.relationshipsList.innerHTML = '';
        const relationships = IntegratedGameState.getActiveRelationships();
        
        if (relationships.length === 0) {
            elements.relationshipsList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary)">No relationships yet. Talk to NPCs!</div>';
            return;
        }
        
        relationships.forEach(npc => {
            const relationshipElement = document.createElement('div');
            relationshipElement.className = 'relationship-item';
            
            relationshipElement.innerHTML = `
                <div class="relationship-info">
                    <div class="relationship-avatar" style="background: ${npc.color}">${npc.emoji}</div>
                    <div>
                        <div class="relationship-name">${npc.name}</div>
                        <div class="relationship-location">${npc.locations[0]}</div>
                    </div>
                </div>
                <div class="relationship-meter">
                    <div class="relationship-level" style="width: ${Math.min(100, npc.relationship)}%; background: ${npc.color}"></div>
                </div>
                <div class="relationship-value">${npc.relationship}</div>
            `;
            
            relationshipElement.addEventListener('click', () => {
                IntegratedGameState.setState({ currentNPC: npc.name });
                updateCurrentNPC();
                elements.relationshipsPanel.style.display = 'none';
                showNotification(`Now talking to ${npc.name}`);
                
                // Update emotion display
                EmotionSystem.updateEmotionDisplay(npc.name);
            });
            
            elements.relationshipsList.appendChild(relationshipElement);
        });
    };
    
    const showJealousyEvent = (npcName) => {
        if (!IntegratedGameState.getState().enhancedMode) return;
        
        elements.jealousyText.textContent = `${npcName} is getting jealous!`;
        elements.jealousyIndicator.style.display = 'flex';
        
        setTimeout(() => {
            elements.jealousyIndicator.style.display = 'none';
        }, 3000);
    };
    
    const showDateScheduler = () => {
        const state = IntegratedGameState.getState();
        if (!state.adultMode) {
            showNotification('Adult Mode required for dating!', 'warning');
            return;
        }
        
        renderDateScheduler();
        elements.dateScheduler.style.display = 'block';
    };
    
    const renderDateScheduler = () => {
        // Render NPC options
        const npcSelect = document.getElementById('date-npc-select');
        npcSelect.innerHTML = '';
        
        const availableNPCs = IntegratedGameState.getActiveRelationships()
            .filter(npc => npc.relationship > 30);
            
        if (availableNPCs.length === 0) {
            npcSelect.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary)">No NPCs available for dating yet. Build relationships first!</div>';
        } else {
            availableNPCs.forEach(npc => {
                const option = document.createElement('div');
                option.className = 'date-option';
                option.textContent = npc.name;
                option.dataset.npc = npc.name;
                npcSelect.appendChild(option);
            });
        }
        
        // Render location options
        const locationSelect = document.getElementById('date-location-select');
        locationSelect.innerHTML = '';
        
        IntegratedGameState.getLocations()
            .filter(loc => loc.dateAvailable && !loc.locked)
            .forEach(location => {
                const option = document.createElement('div');
                option.className = 'date-option';
                option.textContent = location.name;
                option.dataset.location = location.id;
                locationSelect.appendChild(option);
            });
            
        // Render time options
        const timeSelect = document.getElementById('date-time-select');
        if (timeSelect) {
            timeSelect.innerHTML = '';
            ['Evening', 'Night', 'Late Night'].forEach(time => {
                const option = document.createElement('div');
                option.className = 'date-time-option';
                option.textContent = time;
                timeSelect.appendChild(option);
            });
        }
    };
    
    const addEventListener = (elementId, event, handler) => {
        const element = elements[elementId] || document.getElementById(elementId);
        if (!element) return;
        
        element.addEventListener(event, handler);
        const key = `${elementId}_${event}`;
        eventListeners.set(key, { element, event, handler });
    };
    
    const cleanupEventListeners = () => {
        eventListeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        eventListeners.clear();
    };
    
    const renderInventory = () => {
        const inventoryGrid = elements.inventoryGrid;
        inventoryGrid.innerHTML = '';
        
        const state = IntegratedGameState.getState();
        const items = IntegratedGameState.getItems();
        
        // Filter items based on adult mode
        const visibleItems = state.inventory.filter(itemId => {
            const item = items[itemId];
            return item && (state.adultMode || !item.adult);
        });
        
        // NEW: Show condom count in inventory counter
        const condomCount = IntegratedGameState.getCondomCount();
        const hasCondomsInInventory = state.inventory.includes('condom');
        
        elements.inventoryCount.textContent = 
            `${visibleItems.length}${condomCount > 0 && !hasCondomsInInventory ? ` (+${condomCount})` : ''}`;
        
        // Add inventory items
        visibleItems.forEach(itemId => {
            const item = items[itemId];
            if (!item) return;
            
            const itemElement = document.createElement('div');
            itemElement.className = 'inventory-item';
            itemElement.setAttribute('role', 'gridcell');
            itemElement.tabIndex = 0;
            
            if (state.selectedItem === itemId) {
                itemElement.classList.add('selected');
                // Add glow effect for selected item
                if (state.enhancedMode) {
                    itemElement.classList.add('glow');
                }
            }
            
            // NEW: Special display for condoms
            let displayEmoji = item.emoji;
            let displayName = item.name;
            
            if (itemId === 'condom') {
                displayEmoji = 'üíã';
                displayName = `Protection (${condomCount})`;
            }
            
            itemElement.innerHTML = `
                ${displayEmoji}
                <div class="item-name">${displayName}</div>
                ${item.adult ? '<div class="item-adult-badge" style="display: block;">18+</div>' : ''}
            `;
            
            itemElement.title = `${item.name}${item.adult ? ' (Adult Item)' : ''}`;
            
            itemElement.addEventListener('click', () => {
                const newSelected = state.selectedItem === itemId ? null : itemId;
                IntegratedGameState.setSelectedItem(newSelected);
                renderInventory();
                showNotification(`${newSelected === itemId ? 'Selected:' : 'Deselected:'} ${item.name}`);
            });
            
            inventoryGrid.appendChild(itemElement);
        });
        
        // Add empty slots
        const emptySlots = 12 - visibleItems.length;
        for (let i = 0; i < emptySlots; i++) {
            const emptySlot = document.createElement('div');
            emptySlot.className = 'inventory-item';
            emptySlot.style.opacity = '0.3';
            emptySlot.innerHTML = '‚ûï';
            emptySlot.title = 'Empty slot';
            emptySlot.setAttribute('role', 'gridcell');
            inventoryGrid.appendChild(emptySlot);
        }
    };
    
    return {
        elements,
        initialize,
        showLoading,
        hideLoading,
        showNotification,
        updateStats,
        updateQuestTracker,
        addMessage,
        renderComments,
        toggleEnhancedMode,
        updateCurrentNPC,
        renderNPCSelector,
        renderRelationships,
        showJealousyEvent,
        showDateScheduler,
        renderInventory,
        addEventListener,
        cleanupEventListeners
    };
})();

// ===== INTEGRATED SCENE MANAGER (Enhanced with Visuals) =====
const IntegratedSceneManager = (() => {
    const positionItems = (items) => {
        const positions = [];
        const gridCols = 5;
        const gridRows = Math.ceil(items.length / gridCols);
        const padding = 15;
        
        return items.map((item, index) => {
            const row = Math.floor(index / gridCols);
            const col = index % gridCols;
            
            const cellWidth = (100 - 2 * padding) / gridCols;
            const cellHeight = (100 - 2 * padding) / gridRows;
            
            const baseX = padding + col * cellWidth + cellWidth / 2;
            const baseY = padding + row * cellHeight + cellHeight / 2;
            
            const randomX = (Math.random() - 0.5) * (cellWidth * 0.3);
            const randomY = (Math.random() - 0.5) * (cellHeight * 0.3);
            
            const finalX = Math.max(padding, Math.min(100 - padding, baseX + randomX)) - 2.75;
            const finalY = Math.max(padding, Math.min(100 - padding, baseY + randomY)) - 2.75;
            
            return {
                x: finalX,
                y: finalY
            };
        });
    };
    
    const createParticleEffect = (x, y, color = 'var(--warning)') => {
        const container = document.getElementById('scene');
        for (let i = 0; i < 8; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.background = color;
            particle.style.left = `${x}%`;
            particle.style.top = `${y}%`;
            particle.style.position = 'absolute';
            particle.style.borderRadius = '50%';
            particle.style.zIndex = '100';
            particle.style.animation = `collect 0.6s ease forwards`;
            particle.style.animationDelay = `${i * 0.05}s`;
            container.appendChild(particle);
            
            setTimeout(() => particle.remove(), 600);
        }
    };
    
    const renderScene = () => {
        const state = IntegratedGameState.getState();
        const location = IntegratedGameState.getLocation(state.currentLocation);
        const itemsContainer = IntegratedUIManager.elements.itemsContainer;
        
        if (!location) return;
        
        IntegratedUIManager.elements.locationName.textContent = location.name;
        
        // Record location visit for analytics
        IntegratedGameState.recordLocationVisit(state.currentLocation);
        
        // Clear items
        itemsContainer.innerHTML = '';
        
        // Get available items (filtered by respawn system)
        const availableItems = IntegratedGameState.getAvailableItems(state.currentLocation);
        
        // Filter items based on adult mode
        const visibleItems = availableItems.filter(itemId => {
            const item = IntegratedGameState.getItem(itemId);
            return item && (state.adultMode || !item.adult);
        });
        
        // Position items
        const positions = positionItems(visibleItems);
        
        // Create item elements
        visibleItems.forEach((itemId, index) => {
            const item = IntegratedGameState.getItem(itemId);
            if (!item) return;
            
            const position = positions[index];
            const itemElement = document.createElement('div');
            
            itemElement.className = `interactive-item ${item.adult ? 'item-adult' : ''}`;
            if (state.enhancedMode && (item.adult || Math.random() > 0.7)) {
                itemElement.classList.add('glow');
            }
            itemElement.textContent = item.emoji;
            itemElement.title = `${item.name}${item.adult ? ' (18+)' : ''}`;
            itemElement.setAttribute('role', 'button');
            itemElement.setAttribute('aria-label', `Collect ${item.name}`);
            itemElement.tabIndex = 0;
            
            // Set position
            itemElement.style.left = `${position.x}%`;
            itemElement.style.top = `${position.y}%`;
            itemElement.style.zIndex = index + 1;
            itemElement.style.transform = `rotate(${Math.random() * 20 - 10}deg)`;
            itemElement.style.animationDelay = `${index * 0.1}s`;
            
            // Add click event
            itemElement.addEventListener('click', (e) => {
                // Create particle effect
                createParticleEffect(position.x, position.y, item.adult ? 'var(--adult)' : 'var(--warning)');
                IntegratedInventoryManager.collectItem(itemId, e);
            });
            
            // Add touch support for mobile
            itemElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                createParticleEffect(position.x, position.y, item.adult ? 'var(--adult)' : 'var(--warning)');
                IntegratedInventoryManager.collectItem(itemId, { target: itemElement });
            });
            
            itemsContainer.appendChild(itemElement);
        });
        
        // Show respawning items as faded out
        const collectedItems = Object.keys(IntegratedGameState.getState().collectedItems)
            .filter(key => key.startsWith(state.currentLocation + '_'))
            .map(key => key.split('_')[1]);
        
        collectedItems.forEach((itemId, index) => {
            const item = IntegratedGameState.getItem(itemId);
            if (!item) return;
            
            const itemElement = document.createElement('div');
            itemElement.className = 'interactive-item respawning';
            itemElement.textContent = item.emoji;
            itemElement.title = `${item.name} (Respawning...)`;
            itemElement.setAttribute('role', 'presentation');
            
            // Position in a grid at the bottom
            const col = index % 5;
            const row = Math.floor(index / 5);
            itemElement.style.left = `${15 + col * 15}%`;
            itemElement.style.top = `${80 + row * 15}%`;
            itemElement.style.opacity = '0.3';
            itemElement.style.animation = 'respawnPulse 1s ease-in-out infinite';
            
            itemsContainer.appendChild(itemElement);
        });
        
        // Render NPC characters
        renderNPCCharacters();
        
        // If no items, show a message
        if (visibleItems.length === 0 && collectedItems.length === 0) {
            const noItemsMsg = document.createElement('div');
            noItemsMsg.style.position = 'absolute';
            noItemsMsg.style.top = '50%';
            noItemsMsg.style.left = '50%';
            noItemsMsg.style.transform = 'translate(-50%, -50%)';
            noItemsMsg.style.color = 'var(--text-secondary)';
            noItemsMsg.style.fontStyle = 'italic';
            noItemsMsg.textContent = 'No interactive items here';
            itemsContainer.appendChild(noItemsMsg);
        }
    };
    
    const renderNPCCharacters = () => {
        const characterContainer = IntegratedUIManager.elements.playerCharacter.parentElement;
        const state = IntegratedGameState.getState();
        const location = IntegratedGameState.getLocation(state.currentLocation);
        
        if (!location) return;
        
        // Remove existing NPCs (keep player character and Eve)
        const existingNPCs = characterContainer.querySelectorAll('.npc');
        existingNPCs.forEach(npc => {
            if (npc.id !== 'eve-character') npc.remove();
        });
        
        // Get available NPCs for this location
        const availableNPCs = IntegratedGameState.getAvailableNPCs();
        
        // Add NPC characters (always show available NPCs in enhanced mode)
        availableNPCs.forEach((npc, index) => {
            // Skip Eve (already exists)
            if (npc.name === 'Eve') return;
            
            // In enhanced mode, show all available NPCs
            // In basic mode, only show current NPC if they're in this location
            if (!state.enhancedMode && npc.name !== state.currentNPC) return;
            
            const npcElement = document.createElement('div');
            npcElement.className = `npc ${npc.id} animated`;
            npcElement.id = `${npc.id}-character`;
            npcElement.setAttribute('role', 'button');
            npcElement.tabIndex = 0;
            npcElement.setAttribute('aria-label', `NPC character ${npc.name}`);
            
            // Position NPCs with spacing
            const offset = (index) * 100; // 100px spacing
            npcElement.style.position = 'absolute';
            npcElement.style.right = `${20 + offset}px`;
            npcElement.style.bottom = '30px';
            
            npcElement.innerHTML = `
                <div class="npc-body"></div>
                <div class="npc-head"></div>
                <div class="npc-tooltip">${npc.name}</div>
            `;
            
            npcElement.addEventListener('click', () => {
                IntegratedGameState.setState({ currentNPC: npc.name });
                IntegratedUIManager.updateCurrentNPC();
                IntegratedUIManager.showNotification(`Now interacting with ${npc.name}`);
                IntegratedDialogManager.updateDialogOptions();
                
                // Update emotion display
                EmotionSystem.updateEmotionDisplay(npc.name);
            });
            
            characterContainer.appendChild(npcElement);
        });
    };
    
    const renderMiniMap = () => {
        const miniMap = IntegratedUIManager.elements.miniMap;
        const locations = IntegratedGameState.getLocations();
        const state = IntegratedGameState.getState();
        
        miniMap.innerHTML = '';
        
        locations.forEach((location, index) => {
            const dot = document.createElement('div');
            dot.className = `map-dot ${location.id === state.currentLocation ? 'active' : ''} ${location.locked ? 'locked' : ''}`;
            dot.title = `${location.name}${location.locked ? ' (Locked)' : ''}`;
            dot.setAttribute('role', 'button');
            dot.setAttribute('aria-label', `Travel to ${location.name}`);
            dot.tabIndex = 0;
            
            if (location.locked) {
                dot.style.background = '#7f8c8d';
                dot.style.opacity = '0.5';
                dot.style.cursor = 'not-allowed';
            }
            
            dot.addEventListener('click', () => {
                if (location.locked) {
                    if (location.id === 'hotelRoom' && state.relationship < 70) {
                        IntegratedUIManager.showNotification(`You need relationship level 70+ to access the Hotel Suite! (Current: ${state.relationship})`, 'error');
                        return;
                    }
                }
                
                // Scene transition effect
                const transition = document.getElementById('scene-transition');
                transition.style.opacity = '1';
                
                setTimeout(() => {
                    IntegratedGameState.setState({ currentLocation: location.id });
                    renderScene();
                    renderMiniMap();
                    IntegratedUIManager.showNotification(`Traveled to: ${location.name}`);
                    IntegratedUIManager.addMessage(`Larry: *Arrives at ${location.name}*`, 'player');
                    
                    // Fade out transition
                    transition.style.opacity = '0';
                }, 300);
            });
            
            miniMap.appendChild(dot);
        });
    };
    
    return {
        renderScene,
        renderMiniMap
    };
})();

// ===== INTEGRATED INVENTORY MANAGER =====
const IntegratedInventoryManager = (() => {
    const renderInventory = () => {
        IntegratedUIManager.renderInventory();
    };
    
    const collectItem = (itemId, event) => {
        const state = IntegratedGameState.getState();
        const items = IntegratedGameState.getItems();
        const item = items[itemId];
        
        if (!item) return;
        
        // NEW: Special handling for condoms
        if (itemId === 'condom') {
            // Don't add to inventory array, just increment count
            IntegratedGameState.restockCondom();
            IntegratedUIManager.showNotification(`‚úÖ Protection restocked! Now have ${IntegratedGameState.getCondomCount()}.`, 'success');
            renderInventory(); // Refresh display
            
            // Mark as collected for respawn
            IntegratedGameState.markItemCollected(state.currentLocation, itemId);
            IntegratedSceneManager.renderScene();
            return;
        }
        
        // Check if already in inventory
        if (state.inventory.includes(itemId)) {
            IntegratedUIManager.showNotification(`Already have: ${item.name}`);
            return;
        }
        
        // Check adult mode
        if (item.adult && !state.adultMode) {
            IntegratedUIManager.showNotification('Adult content item - Enable Adult Mode to collect', 'warning');
            return;
        }
        
        // Check inventory limit
        if (state.inventory.length >= 12) {
            IntegratedUIManager.showNotification('Inventory full! Cannot collect more items.', 'error');
            return;
        }
        
        // Animation
        const itemElement = event.target;
        itemElement.classList.add('collecting');
        
        // Create flying animation
        const itemClone = itemElement.cloneNode(true);
        itemClone.style.position = 'fixed';
        itemClone.style.zIndex = '1000';
        itemClone.style.animation = 'none';
        itemClone.style.transition = 'all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
        
        // Get original position
        const itemRect = itemElement.getBoundingClientRect();
        itemClone.style.left = `${itemRect.left}px`;
        itemClone.style.top = `${itemRect.top}px`;
        
        document.body.appendChild(itemClone);
        
        const inventoryPanel = document.querySelector('.inventory-panel');
        const inventoryRect = inventoryPanel.getBoundingClientRect();
        
        setTimeout(() => {
            itemClone.style.left = `${inventoryRect.left + 20}px`;
            itemClone.style.top = `${inventoryRect.top + 20}px`;
            itemClone.style.transform = 'scale(0.5) rotate(720deg)';
            itemClone.style.opacity = '0';
        }, 10);
        
        setTimeout(() => {
            itemClone.remove();
            
            // Mark item as collected for respawn system
            IntegratedGameState.markItemCollected(state.currentLocation, itemId);
            
            // Add to inventory
            const newInventory = [...state.inventory, itemId];
            const newScore = state.score + 50 + (item.adult ? 50 : 0);
            
            IntegratedGameState.setState({
                inventory: newInventory,
                score: newScore
            });
            
            IntegratedUIManager.showNotification(`Found: ${item.name}! +${50 + (item.adult ? 50 : 0)} points`, item.adult ? 'adult' : '');
            
            // Quest progress
            if (itemId === 'flowers') IntegratedQuestManager.updateQuestProgress(3, 50);
            if (itemId === 'perfume') IntegratedQuestManager.updateQuestProgress(4, 50);
            if (itemId === 'roomKey') IntegratedQuestManager.updateQuestProgress(5, 50);
            if (itemId === 'wine' || itemId === 'champagne') IntegratedQuestManager.updateQuestProgress(6, 10);
            if (itemId === 'drink') IntegratedQuestManager.updateQuestProgress(2, 30);
            
            // Check achievements
            AchievementSystem.checkAchievement('collector');
            
            renderInventory();
            IntegratedUIManager.updateStats();
            IntegratedQuestManager.updateOverallProgress();
            
            // Re-render scene (items will be removed)
            IntegratedSceneManager.renderScene();
        }, 600);
    };
    
    return {
        renderInventory,
        collectItem
    };
})();

// ===== INTEGRATED DIALOG MANAGER (Enhanced with Emotion and Story) - REWRITTEN =====
const IntegratedDialogManager = (() => {
    const updateDialogOptions = () => {
        const dialogOptions = IntegratedUIManager.elements.dialogOptions;
        dialogOptions.innerHTML = '';
        
        const state = IntegratedGameState.getState();
        const npc = IntegratedGameState.getNPC(state.currentNPC);
        const currentQuest = IntegratedGameState.getCurrentQuest();
        
        // Base options (original + enhanced)
        const options = [
            { 
                text: "Compliment her appearance", 
                mood: 10, 
                relationship: 5, 
                adult: 0, 
                questId: 1, 
                progress: 30,
                type: "compliment",
                category: "basic"
            },
            { 
                text: "Offer a drink", 
                mood: 5, 
                relationship: 3, 
                adult: 0, 
                questId: 2, 
                progress: 50,
                type: "drink",
                category: "basic"
            },
            { 
                text: "Tell a joke", 
                mood: -5, 
                relationship: 2, 
                adult: 0,
                type: "humor",
                category: "basic"
            },
            { 
                text: "Ask about her interests", 
                mood: 15, 
                relationship: 8, 
                adult: 0, 
                questId: 1, 
                progress: 20,
                type: "interest",
                category: "basic"
            },
            { 
                text: "Share a personal story", 
                mood: 20, 
                relationship: 12, 
                adult: 0, 
                questId: 1, 
                progress: 25,
                type: "story",
                category: "personal"
            }
        ];
        
        // Add NPC-specific options in enhanced mode
        if (state.enhancedMode && npc) {
            const dialogs = IntegratedGameState.getNPCDialogs(state.currentNPC);
            
            // Replace generic options with NPC-specific ones
            options[0].text = `Compliment ${npc.name}'s appearance`;
            options[3].text = `Ask about ${npc.name}'s interests`;
            
            // Add emotion-based options
            const emotion = EmotionSystem.getEmotion(state.currentNPC);
            if (emotion) {
                switch(emotion.current) {
                    case 'joy':
                        options.push({ 
                            text: `Make ${npc.name} laugh`, 
                            mood: 15, 
                            relationship: 10, 
                            adult: 0, 
                            emotion: 'joy',
                            type: "humor",
                            category: "emotion"
                        });
                        break;
                    case 'sadness':
                        options.push({ 
                            text: `Cheer up ${npc.name}`, 
                            mood: 20, 
                            relationship: 15, 
                            adult: 0, 
                            emotion: 'sadness',
                            type: "support",
                            category: "emotion"
                        });
                        break;
                    case 'anger':
                        options.push({ 
                            text: `Calm ${npc.name} down`, 
                            mood: 15, 
                            relationship: 12, 
                            adult: 0, 
                            emotion: 'anger',
                            type: "apology",
                            category: "emotion"
                        });
                        break;
                }
            }
            
            // Add NPC-specific story options
            if (npc.storyProgress > 0) {
                options.push({ 
                    text: `Continue ${npc.name}'s story`, 
                    mood: 25, 
                    relationship: 15, 
                    adult: 0,
                    npcSpecific: true,
                    type: "story",
                    category: "personal"
                });
            }
            
            // Add gift options based on NPC preferences
            const gifts = ['flowers', 'chocolate', 'wine', 'perfume', 'cigar', 'whiskey', 'champagne'];
            gifts.forEach(gift => {
                if (state.inventory.includes(gift) && npc.giftPreferences.includes(gift)) {
                    const giftItem = IntegratedGameState.getItem(gift);
                    options.push({ 
                        text: `Give ${giftItem.name} to ${npc.name}`, 
                        mood: 30, 
                        relationship: 20, 
                        adult: 0,
                        item: gift,
                        npcSpecific: true,
                        type: "gift",
                        category: "gift"
                    });
                }
            });
            
            // Add emotion manipulation options based on current emotion
            if (emotion) {
                options.push({ 
                    text: `Try to make ${npc.name} feel ${emotion.current}`, 
                    mood: 10, 
                    relationship: 8, 
                    adult: 0,
                    emotionManipulation: emotion.current,
                    enhanced: true,
                    type: "emotion",
                    category: "emotion"
                });
            }
        }
        
        // Smart option only in AI mode
        if (IntegratedNPCAI.getAIMode()) {
            options.push({
                text: "Try a clever pickup line", 
                mood: 15, 
                relationship: 10, 
                adult: 0, 
                questId: 1, 
                progress: 20, 
                smart: true,
                type: "flirt",
                category: "smart"
            });
        }
        
        // Adult options
        if (state.adultMode && state.relationship > 40) {
            options.push({
                text: "Make a suggestive comment", 
                mood: -10, 
                relationship: 10, 
                adult: 3, 
                questId: 6, 
                progress: 15,
                type: "flirt",
                category: "adult"
            });
        }
        
        if (state.adultMode && state.relationship > 60) {
            options.push({
                text: "Whisper something naughty", 
                mood: 5, 
                relationship: 20, 
                adult: 7, 
                questId: 6, 
                progress: 30,
                type: "flirt",
                category: "adult"
            });
        }
        
        // Quest-specific options
        if (currentQuest && !currentQuest.completed) {
            if (currentQuest.id === 3 && state.inventory.includes('flowers')) {
                options.push({ 
                    text: state.enhancedMode ? `Give ${npc?.name || 'her'} the flowers` : "Give her the flowers", 
                    mood: 30, 
                    relationship: 20, 
                    adult: 0, 
                    questId: 3, 
                    progress: 100,
                    type: "gift",
                    category: "quest"
                });
            }
            if (currentQuest.id === 4 && state.inventory.includes('perfume')) {
                options.push({ 
                    text: state.enhancedMode ? `Give ${npc?.name || 'her'} the perfume` : "Give her the perfume", 
                    mood: 25, 
                    relationship: 15, 
                    adult: 0, 
                    questId: 4, 
                    progress: 100,
                    type: "gift",
                    category: "quest"
                });
            }
        }
        
        // Date invitation in enhanced mode
        if (state.enhancedMode && npc && npc.relationship > 50) {
            options.push({ 
                text: `Invite ${npc.name} on a date`, 
                mood: 20, 
                relationship: 15, 
                adult: true, 
                type: 'date',
                npcSpecific: true,
                category: "social"
            });
        }
        
        // Create option elements
        options.forEach((option, index) => {
            const optionElement = document.createElement('div');
            optionElement.className = `dialog-option ${option.adult > 0 ? 'adult-option' : ''} ${option.smart ? 'ai-option' : ''} ${option.npcSpecific ? 'npc-specific' : ''} ${option.emotion ? 'emotion-option' : ''} ${option.category}-option`;
            optionElement.textContent = `${index + 1}. ${option.text}`;
            optionElement.setAttribute('role', 'menuitem');
            optionElement.tabIndex = 0;
            
            // Style based on category
            const categoryStyles = {
                basic: { borderLeft: '4px solid var(--primary)' },
                emotion: { borderLeft: '4px solid var(--emotion)' },
                personal: { borderLeft: '4px solid var(--trust)' },
                gift: { borderLeft: '4px solid var(--joy)' },
                smart: { borderLeft: '4px solid var(--warning)' },
                adult: { borderLeft: '4px solid var(--adult)' },
                quest: { borderLeft: '4px solid var(--success)' },
                social: { borderLeft: '4px solid var(--anticipation)' }
            };
            
            if (categoryStyles[option.category]) {
                Object.assign(optionElement.style, categoryStyles[option.category]);
            }
            
            if (option.smart) {
                optionElement.style.border = '2px solid var(--primary)';
                optionElement.style.background = 'linear-gradient(135deg, rgba(155, 89, 182, 0.2), rgba(142, 68, 173, 0.2))';
            }
            
            if (option.emotion) {
                const emotionColor = EmotionSystem.getEmotion(npc?.name)?.current === option.emotion ? 
                    `var(--${option.emotion})` : 'var(--primary)';
                optionElement.style.border = `2px solid ${emotionColor}`;
            }
            
            let disabled = false;
            let disabledReason = '';
            
            if (option.adult > 0 && !state.adultMode) {
                disabled = true;
                disabledReason = "Adult content disabled";
            } else if (option.adult > (npc?.adultTolerance || 5)) {
                disabled = true;
                disabledReason = "Too forward for this character";
            } else if (option.text.includes("flowers") && !state.inventory.includes('flowers')) {
                disabled = true;
                disabledReason = "You need flowers first!";
            } else if (option.text.includes("perfume") && !state.inventory.includes('perfume')) {
                disabled = true;
                disabledReason = "You need perfume first!";
            } else if (option.smart && !IntegratedNPCAI.getAIMode()) {
                disabled = true;
                disabledReason = "AI Mode required for smart options";
            } else if (option.type === 'date' && !state.enhancedMode) {
                disabled = true;
                disabledReason = "Enhanced Mode required for dating";
            } else if (option.text.includes("drink") && !state.inventory.includes('drink') && 
                       !IntegratedGameState.isItemAvailable(state.currentLocation, 'drink')) {
                disabled = true;
                disabledReason = "Wait for drinks to respawn at the bar";
            }
            
            if (disabled) {
                optionElement.classList.add('disabled');
                optionElement.title = disabledReason;
            } else {
                optionElement.addEventListener('click', () => {
                    selectDialogOption(option, npc || { name: 'Eve' });
                });
                optionElement.title = getOptionTooltip(option, npc);
            }
            
            dialogOptions.appendChild(optionElement);
        });
    };
    
    const getOptionTooltip = (option, npc) => {
        if (option.questId) return "Advances quest progress";
        if (option.smart) return "Smart AI option";
        if (option.emotion) return "Emotion-based option";
        if (option.npcSpecific) return `${npc?.name || 'NPC'}-specific option`;
        if (option.category === 'gift') return `Uses ${option.item} from inventory`;
        if (option.type === 'date') return "Schedule a romantic date";
        return "Standard dialog option";
    };
    
    const selectDialogOption = (option, npc) => {
        IntegratedUIManager.addMessage(`Larry: ${option.text}`, 'player', option.adult > 0);
        
        // Update quest progress
        if (option.questId && option.progress) {
            IntegratedQuestManager.updateQuestProgress(option.questId, option.progress);
        }
        
        // Handle special option types
        if (option.type === 'date') {
            setTimeout(() => {
                IntegratedUIManager.addMessage(`${npc.name}: A date? I'd like that. Where should we go?`, 'npc', true);
                setTimeout(() => {
                    IntegratedUIManager.showDateScheduler();
                }, 1000);
            }, 500);
            return;
        }
        
        // Handle emotion manipulation
        if (option.emotionManipulation) {
            EmotionSystem.setEmotion(npc.name, option.emotionManipulation, 70);
        }
        
        // Generate response with player's dialog text as context
        setTimeout(() => {
            const npcResponse = IntegratedNPCAI.getResponse(
                IntegratedGameState.getState().mood,
                IntegratedGameState.getState().relationship,
                option.adult,
                npc.name,
                option.text, // Pass player's dialog text
                option.type   // Pass option type for context
            );
            
            IntegratedUIManager.addMessage(`${npc.name}: ${npcResponse}`, 'npc', option.adult > 0);
            
            // Update game state
            const state = IntegratedGameState.getState();
            
            // Apply emotion modifier based on NPC's individual emotion
            const emotionModifier = EmotionSystem.getEmotionModifier(npc.name, 'mood');
            const responseModifier = EmotionSystem.getEmotionModifier(npc.name, 'response');
            
            const adjustedMoodChange = Math.floor(option.mood * emotionModifier);
            const adjustedRelationshipChange = Math.floor(option.relationship * responseModifier);
            
            const newMood = Math.max(0, Math.min(100, state.mood + adjustedMoodChange));
            const newRelationship = state.relationship + adjustedRelationshipChange;
            const newScore = state.score + 25 + (option.adult * 10) + (option.smart ? 15 : 0);
            
            // Update NPC relationship with tracking
            IntegratedGameState.updateNPCRelationship(npc.name, adjustedRelationshipChange);
            
            IntegratedGameState.setState({
                mood: newMood,
                score: newScore
            });
            
            // Update NPC state with individual mood changes
            if (state.enhancedMode) {
                IntegratedGameState.updateNPC(npc.name, {
                    baseMood: Math.max(0, Math.min(100, npc.baseMood + adjustedMoodChange)),
                    intimacy: option.adult > 0 ? npc.intimacy + option.adult : npc.intimacy,
                    storyProgress: option.npcSpecific ? npc.storyProgress + 1 : npc.storyProgress
                });
                
                // Update enhanced quests
                if (npc.name === state.currentNPC) {
                    // Give bonus progress for any successful interaction
                    if (option.mood > 0 && option.relationship > 0) {
                        IntegratedQuestManager.updateQuestProgress(7, 5); // Meet All NPCs progress
                        IntegratedQuestManager.updateQuestProgress(1, option.smart ? 15 : 10);
                        
                        // Check for story progress
                        if (npc.relationship + adjustedRelationshipChange > 20) {
                            IntegratedQuestManager.updateQuestProgress(11, 10);
                        }
                        
                        // Check for emotion progress
                        if (option.emotion) {
                            IntegratedQuestManager.updateQuestProgress(12, 15);
                        }
                    }
                    
                    // Check for True Love quest
                    if (npc.relationship + adjustedRelationshipChange >= 100) {
                        IntegratedQuestManager.updateQuestProgress(9, 100);
                    }
                    
                    // Check for Player quest
                    const activeNPCs = IntegratedGameState.getActiveRelationships();
                    if (activeNPCs.filter(n => n.relationship >= 50).length >= 4) {
                        IntegratedQuestManager.updateQuestProgress(10, 100);
                    }
                }
            } else {
                // Original quest progress
                if (npc.name === 'Eve') {
                    if (option.mood > 0 && option.relationship > 0) {
                        IntegratedQuestManager.updateQuestProgress(1, option.smart ? 15 : 10);
                    }
                    
                    if (npcResponse.includes("full attention") || npcResponse.includes("my attention now")) {
                        IntegratedQuestManager.updateQuestProgress(1, 50);
                        IntegratedUIManager.showNotification("üèÜ Eve is fully attentive!", "success");
                    }
                    
                    if (newMood > 70) {
                        IntegratedQuestManager.updateQuestProgress(1, 15);
                    }
                }
            }
            
            IntegratedUIManager.updateStats();
            IntegratedQuestManager.updateOverallProgress();
            
            // Add NPC comment with context from player's dialog
            const comment = IntegratedNPCAI.generateComment(npc.name, option.adult, option.text, option.type);
            if (comment) { // Only add comment if not in cooldown
                IntegratedGameState.addComment({
                    npc: npc.name,
                    text: comment,
                    time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    adult: option.adult > 0
                });
                IntegratedUIManager.renderComments();
            }
            
            // Visual feedback
            if (option.mood > 0) {
                const npcCharacter = document.getElementById(`${npc.id}-character`) || IntegratedUIManager.elements.eveCharacter;
                if (npcCharacter) {
                    npcCharacter.style.transform = 'translateY(-10px) scale(1.1)';
                    setTimeout(() => {
                        npcCharacter.style.transform = 'translateY(0) scale(1)';
                    }, 500);
                }
            }
            
            // Check for special events
            checkSpecialEvents(option, npc);
            
            // Update jealousy
            if (state.enhancedMode) {
                IntegratedGameState.updateJealousy();
                const jealousyLevel = IntegratedGameState.getState().jealousyLevel;
                if (jealousyLevel > 50 && Math.random() > 0.7) {
                    IntegratedUIManager.showJealousyEvent(npc.name);
                }
            }
            
            // Remove consumable items from inventory when used
            if (option.item && IntegratedGameState.getState().inventory.includes(option.item)) {
                const newInventory = state.inventory.filter(item => item !== option.item);
                IntegratedGameState.setState({ inventory: newInventory });
                IntegratedInventoryManager.renderInventory();
            }
            
            // Update dialog options
            updateDialogOptions();
        }, 500);
    };
    
    const checkSpecialEvents = (option, npc) => {
        const state = IntegratedGameState.getState();
        const locations = IntegratedGameState.getLocations();
        
        // Unlock hotel room
        if (state.relationship >= 70 && locations[4].locked) {
            locations[4].locked = false;
            IntegratedUIManager.showNotification('üè® Hotel Suite unlocked! Relationship level reached!', 'adult');
            IntegratedGameState.addComment({
                npc: npc.name,
                text: 'Maybe we should continue this in my suite...',
                time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                adult: true
            });
            IntegratedUIManager.renderComments();
            IntegratedSceneManager.renderMiniMap();
        }
    };
    
    return {
        updateDialogOptions,
        selectDialogOption
    };
})();

// ===== INTEGRATED ITEM USE HANDLER =====
const IntegratedItemUseHandler = (() => {
    const useSelectedItem = () => {
        const selectedItemId = IntegratedGameState.getSelectedItem();
        const state = IntegratedGameState.getState();
        
        if (!selectedItemId) {
            IntegratedUIManager.showNotification('Select an item from inventory first!', 'warning');
            return;
        }
        
        const item = IntegratedGameState.getItem(selectedItemId);
        if (!item) return;
        
        IntegratedUIManager.addMessage(`Larry: *Uses ${item.name}*`, 'player', item.adult);
        
        let moodChange = 0;
        let relationshipChange = 0;
        let questProgress = 0;
        let emotionEffect = null;
        
        switch(selectedItemId) {
            case 'flowers':
                moodChange = 20;
                relationshipChange = 10;
                questProgress = 50;
                emotionEffect = 'joy';
                IntegratedQuestManager.updateQuestProgress(3, questProgress);
                break;
            case 'drink':
                moodChange = 15;
                relationshipChange = 5;
                questProgress = 50;
                emotionEffect = 'joy';
                IntegratedQuestManager.updateQuestProgress(2, questProgress);
                break;
            case 'wine':
                moodChange = 25;
                relationshipChange = 15;
                questProgress = 25;
                emotionEffect = 'trust';
                IntegratedQuestManager.updateQuestProgress(6, questProgress);
                break;
            case 'champagne':
                moodChange = 30;
                relationshipChange = 20;
                questProgress = 30;
                emotionEffect = 'joy';
                IntegratedQuestManager.updateQuestProgress(6, questProgress);
                break;
            case 'condom':
                if (state.adultMode && state.relationship > 60) {
                    // NEW: Check if we have condoms available
                    if (!IntegratedGameState.canUseCondom()) {
                        IntegratedUIManager.showNotification('No protection available! Restock at the bar, hotel, or casino.', 'warning');
                        moodChange = -10;
                        relationshipChange = -5;
                        break;
                    }
                    
                    // Use a condom
                    IntegratedGameState.useCondom();
                    
                    moodChange = 40;
                    relationshipChange = 30;
                    questProgress = 50;
                    emotionEffect = 'trust';
                    IntegratedQuestManager.updateQuestProgress(6, questProgress);
                    IntegratedGameState.addComment({
                        npc: state.currentNPC || 'Eve',
                        text: 'He came prepared... smart and responsible.',
                        time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                        adult: true
                    });
                    
                    // NEW: Auto-restock notification
                    if (IntegratedGameState.getCondomCount() <= 1) {
                        IntegratedUIManager.showNotification('‚ö†Ô∏è Low on protection! Visit the bar, hotel, or casino to restock.', 'warning');
                    }
                } else {
                    moodChange = -20;
                    relationshipChange = -10;
                    IntegratedUIManager.showNotification('Too soon for that! Build relationship first.', 'warning');
                }
                break;
            case 'perfume':
                moodChange = 25;
                relationshipChange = 15;
                questProgress = 50;
                emotionEffect = 'anticipation';
                IntegratedQuestManager.updateQuestProgress(4, questProgress);
                break;
            case 'roomKey':
                moodChange = 35;
                relationshipChange = 25;
                questProgress = 50;
                emotionEffect = 'surprise';
                IntegratedQuestManager.updateQuestProgress(5, questProgress);
                break;
            default:
                moodChange = 5;
                relationshipChange = 3;
        }
        
        // Apply emotion effect if present
        if (emotionEffect && state.enhancedMode) {
            EmotionSystem.influenceEmotion(state.currentNPC, emotionEffect, 20);
        }
        
        // Also give progress for attention quest when using items successfully
        if (moodChange > 0 && relationshipChange > 0) {
            IntegratedQuestManager.updateQuestProgress(1, 15);
        }
        
        setTimeout(() => {
            const responses = [
                'Nice try, but not quite.',
                'Interesting choice...',
                'That was... unexpected.',
                'You\'re full of surprises.'
            ];
            
            if (moodChange > 20) {
                IntegratedUIManager.addMessage(`${state.currentNPC || 'Eve'}: Oh my! You really know how to impress a girl!`, 'npc', item.adult);
            } else if (moodChange > 0) {
                IntegratedUIManager.addMessage(`${state.currentNPC || 'Eve'}: ${responses[Math.floor(Math.random() * responses.length)]}`, 'npc', item.adult);
            } else {
                IntegratedUIManager.addMessage(`${state.currentNPC || 'Eve'}: That was... inappropriate.`, 'npc');
            }
            
            const newMood = Math.max(0, Math.min(100, state.mood + moodChange));
            const newRelationship = state.relationship + relationshipChange;
            const newScore = state.score + 50;
            
            // Update NPC relationship with tracking
            IntegratedGameState.updateNPCRelationship(state.currentNPC, relationshipChange);
            
            IntegratedGameState.setState({
                mood: newMood,
                score: newScore,
                selectedItem: null
            });
            
            // Update NPC in enhanced mode
            if (state.enhancedMode) {
                const npc = IntegratedGameState.getNPC(state.currentNPC);
                if (npc) {
                    IntegratedGameState.updateNPC(state.currentNPC, {
                        baseMood: Math.min(100, npc.baseMood + moodChange)
                    });
                }
            }
            
            // Remove consumable items from inventory (except condoms which are tracked separately)
            const consumables = ['drink', 'wine', 'champagne', 'flowers', 'perfume', 'chocolate', 'cigar', 'whiskey', 'candle', 'lube'];
            if (consumables.includes(selectedItemId)) {
                const newInventory = state.inventory.filter(itemId => itemId !== selectedItemId);
                IntegratedGameState.setState({ inventory: newInventory });
            }
            
            IntegratedUIManager.updateStats();
            IntegratedInventoryManager.renderInventory();
        }, 500);
    };
    
    return {
        useSelectedItem
    };
})();

// ===== ENHANCED NPC AI SYSTEM (Enhanced with Emotion) - REWRITTEN =====
const IntegratedNPCAI = (() => {
    let aiMode = true;
    const commentCooldowns = new Map();
    
    const responses = {
        // AI Mode Responses - NPC-specific templates
        ai_neutral: {
            Eve: ["Interesting approach.", "You're not like the others.", "I'm listening."],
            Jessica: ["Hey there!", "What's up?", "Tell me more!"],
            Danielle: ["That's interesting.", "I see.", "Please continue."],
            Ashley: ["Cool!", "Nice!", "Tell me more!"],
            Nicole: ["Interesting observation.", "Go on.", "I'm listening."]
        },
        ai_positive: {
            Eve: ["You're making this difficult to resist.", "Okay, you've got my attention now."],
            Jessica: ["You're so charming!", "I like your style!", "Keep talking like that!"],
            Danielle: ["That's very sweet of you.", "You're quite the romantic.", "Thank you for saying that."],
            Ashley: ["Aw, thanks!", "You're awesome!", "That's so nice!"],
            Nicole: ["You're quite perceptive.", "That's... intriguing.", "You have good taste."]
        },
        ai_negative: {
            Eve: ["Seriously? That's your best line?", "You're trying too hard."],
            Jessica: ["Ugh, really?", "That's not working.", "Try again!"],
            Danielle: ["That's... inappropriate.", "Please be more respectful."],
            Ashley: ["Not cool!", "That's rude!", "No thanks!"],
            Nicole: ["Poor choice of words.", "That won't work here.", "Try a different approach."]
        },
        ai_adult: {
            Eve: ["Now you're speaking my language.", "You have my attention... and my interest."],
            Jessica: ["Ooh, I like where this is going!", "Now we're talking!", "You're being naughty!"],
            Danielle: ["You're being quite forward...", "That's... bold of you to say."],
            Ashley: ["Whoa, smooth!", "You're cheeky!", "Haha, nice one!"],
            Nicole: ["Bold move.", "You're not afraid to be direct.", "Interesting proposition."]
        },
        
        // Simple Mode Responses
        simple_neutral: [
            "I see.",
            "Okay.",
            "Hmm.",
            "Interesting.",
            "I understand."
        ],
        simple_positive: [
            "That's nice.",
            "Good to know.",
            "Thank you.",
            "That's interesting.",
            "I appreciate that."
        ],
        simple_negative: [
            "I disagree.",
            "No thank you.",
            "That's not for me.",
            "I'd rather not.",
            "Let's change the subject."
        ],
        simple_adult: [
            "That's inappropriate.",
            "Please be respectful.",
            "Let's keep it friendly.",
            "I prefer polite conversation.",
            "That's not appropriate here."
        ]
    };
    
    // Context-aware dialog responses based on player's choice
    const getContextResponse = (npcName, playerText, optionType, relationship) => {
        const npcData = IntegratedGameState.getNPC(npcName);
        const emotion = EmotionSystem.getEmotion(npcName);
        const currentMood = npcData?.baseMood || 50;
        
        // Analyze player's dialog option
        const text = playerText.toLowerCase();
        
        // Determine response category based on option content
        if (optionType === 'compliment' || text.includes('compliment') || text.includes('beautiful') || text.includes('pretty')) {
            return getComplimentResponse(npcName, currentMood, relationship);
        }
        if (optionType === 'flirt' || text.includes('flirt') || text.includes('sexy') || text.includes('attractive')) {
            return getFlirtResponse(npcName, currentMood, relationship);
        }
        if (optionType === 'story' || text.includes('story') || text.includes('tell') || text.includes('share')) {
            return getStoryResponse(npcName, relationship);
        }
        if (text.includes('drink') || text.includes('wine') || text.includes('champagne')) {
            return getDrinkResponse(npcName, currentMood);
        }
        if (text.includes('gift') || text.includes('give') || text.includes('present')) {
            return getGiftResponse(npcName, currentMood);
        }
        
        return null; // No specific context match
    };
    
    const getComplimentResponse = (npcName, mood, relationship) => {
        const responsesByNPC = {
            Eve: {
                highMood: ["You're making me blush.", "That's very sweet of you.", "You have a way with words."],
                mediumMood: ["Thank you.", "That's nice of you.", "I appreciate that."],
                lowMood: ["Flattery will get you nowhere.", "Save the compliments.", "I'm not in the mood."]
            },
            Jessica: {
                highMood: ["Aw, you're making me blush!", "You're so sweet!", "Keep them coming!"],
                mediumMood: ["Thanks, handsome!", "Nice one!", "I like that."],
                lowMood: ["Nice try.", "Not bad.", "Could be better."]
            },
            Danielle: {
                highMood: ["That's very kind of you.", "You're too sweet.", "Thank you for saying that."],
                mediumMood: ["That's nice.", "Thank you.", "I appreciate it."],
                lowMood: ["That's... unnecessary.", "Please don't.", "Let's be professional."]
            },
            Ashley: {
                highMood: ["Awesome!", "You're the best!", "Thanks a bunch!"],
                mediumMood: ["Cool!", "Nice!", "Thanks!"],
                lowMood: ["Uh huh.", "Okay.", "Sure."]
            },
            Nicole: {
                highMood: ["You have good taste.", "Interesting compliment.", "I'll accept that."],
                mediumMood: ["Noted.", "Interesting.", "I see."],
                lowMood: ["Save it.", "Too little too late.", "Unnecessary."]
            }
        };
        
        const npcResponses = responsesByNPC[npcName] || responsesByNPC.Eve;
        let responseSet;
        
        if (mood > 70) responseSet = npcResponses.highMood;
        else if (mood > 40) responseSet = npcResponses.mediumMood;
        else responseSet = npcResponses.lowMood;
        
        return responseSet[Math.floor(Math.random() * responseSet.length)];
    };
    
    const getFlirtResponse = (npcName, mood, relationship) => {
        const responsesByNPC = {
            Eve: {
                highRelationship: ["You're being quite forward... I like it.", "Now you're talking.", "Finally, someone with confidence."],
                mediumRelationship: ["Smooth.", "Interesting approach.", "You have courage, I'll give you that."],
                lowRelationship: ["That's a bit much.", "Let's keep it friendly.", "Too soon for that."]
            },
            Jessica: {
                highRelationship: ["Ooh, I like that!", "You're so smooth!", "Keep going!"],
                mediumRelationship: ["Not bad!", "You're cheeky!", "Haha, nice try!"],
                lowRelationship: ["Easy there!", "Slow down!", "Whoa, cowboy!"]
            },
            Danielle: {
                highRelationship: ["You're being bold tonight.", "That's... direct.", "My, my."],
                mediumRelationship: ["That's forward.", "Interesting.", "Hmm."],
                lowRelationship: ["Please be respectful.", "That's inappropriate.", "Let's maintain decorum."]
            },
            Ashley: {
                highRelationship: ["Haha, smooth!", "You're funny!", "Nice one!"],
                mediumRelationship: ["Cheeky!", "Bold move!", "Hehe."],
                lowRelationship: ["Whoa there!", "Easy tiger!", "Too fast!"]
            },
            Nicole: {
                highRelationship: ["Bold move. I like it.", "You're not afraid, are you?", "Interesting gamble."],
                mediumRelationship: ["Risky play.", "You have nerve.", "Not many would dare."],
                lowRelationship: ["Too bold.", "Reign it in.", "Control yourself."]
            }
        };
        
        const npcResponses = responsesByNPC[npcName] || responsesByNPC.Eve;
        let responseSet;
        
        if (relationship > 60) responseSet = npcResponses.highRelationship;
        else if (relationship > 30) responseSet = npcResponses.mediumRelationship;
        else responseSet = npcResponses.lowRelationship;
        
        return responseSet[Math.floor(Math.random() * responseSet.length)];
    };
    
    const getStoryResponse = (npcName, relationship) => {
        const stories = StoryEngine.generateStoryDialog(npcName, relationship);
        return stories || "That's interesting.";
    };
    
    const getDrinkResponse = (npcName, mood) => {
        const responses = {
            Eve: ["I could use a drink.", "Thanks, I was getting thirsty.", "Perfect timing."],
            Jessica: ["Yay, drinks!", "Ooh, my favorite!", "Cheers!"],
            Danielle: ["Thank you, that's thoughtful.", "How nice of you.", "I appreciate the gesture."],
            Ashley: ["Awesome, thanks!", "You're the best!", "Sweet!"],
            Nicole: ["Interesting choice.", "I accept.", "A drink won't hurt."]
        };
        
        return responses[npcName]?.[Math.floor(Math.random() * responses[npcName].length)] || "Thanks for the drink.";
    };
    
    const getGiftResponse = (npcName, mood) => {
        const responses = {
            Eve: ["You shouldn't have.", "That's thoughtful.", "How nice of you."],
            Jessica: ["Ooh, a present!", "You're so sweet!", "For me? Thank you!"],
            Danielle: ["That's very kind.", "You're too generous.", "Thank you for the gift."],
            Ashley: ["Wow, thanks!", "You're awesome!", "Cool gift!"],
            Nicole: ["A gift? Interesting.", "I'll accept this.", "You're generous."]
        };
        
        return responses[npcName]?.[Math.floor(Math.random() * responses[npcName].length)] || "Thank you for the gift.";
    };
    
    const setAIMode = (enabled) => {
        aiMode = enabled;
    };
    
    const getAIMode = () => aiMode;
    
    const getResponse = (mood, relationship, adultLevel = 0, npcName = 'Eve', playerText = "", optionType = "") => {
        const state = IntegratedGameState.getState();
        const npc = IntegratedGameState.getNPC(npcName);
        const currentMood = npc?.baseMood || mood;
        const currentRelationship = npc?.relationship || relationship;
        
        // 1. Try context-aware response first (30% chance)
        if (playerText && optionType && Math.random() < 0.3) {
            const contextResponse = getContextResponse(npcName, playerText, optionType, currentRelationship);
            if (contextResponse) {
                return contextResponse;
            }
        }
        
        // 2. Check for emotion response (REDUCED from 70% to 30% chance)
        if (Math.random() < 0.3) {
            const emotionResponse = EmotionSystem.getEmotionResponse(
                npcName, 
                adultLevel > 0 ? 'insult' : 'compliment'
            );
            if (emotionResponse) {
                return emotionResponse;
            }
        }
        
        // 3. Base response based on NPC-specific data
        let responseSet;
        
        if (aiMode) {
            // AI Mode: Use NPC-specific responses
            if (currentRelationship > 70 && adultLevel > 0 && state.adultMode) {
                responseSet = responses.ai_adult[npcName] || responses.ai_adult.Eve;
            } else if (currentMood > 70) {
                responseSet = responses.ai_positive[npcName] || responses.ai_positive.Eve;
            } else if (currentMood > 40) {
                responseSet = responses.ai_neutral[npcName] || responses.ai_neutral.Eve;
            } else {
                responseSet = responses.ai_negative[npcName] || responses.ai_negative.Eve;
            }
        } else {
            // Simple Mode: Static responses
            if (adultLevel > 0 && state.adultMode) {
                responseSet = responses.simple_adult;
            } else if (currentMood > 60) {
                responseSet = responses.simple_positive;
            } else if (currentMood > 30) {
                responseSet = responses.simple_neutral;
            } else {
                responseSet = responses.simple_negative;
            }
        }
        
        // Add personality-specific flavor
        if (npc) {
            const personalityResponses = {
                confident: ["I like your confidence.", "You've got nerve.", "Bold move."],
                flirtatious: ["You're making this fun!", "Keep going!", "I like your style!"],
                romantic: ["That's beautiful.", "You're quite the poet.", "How romantic."],
                fun: ["This is fun!", "You're hilarious!", "Awesome!"],
                mysterious: ["Intriguing.", "You're full of surprises.", "Interesting."]
            };
            
            if (personalityResponses[npc.personality] && Math.random() > 0.7) {
                responseSet = [...responseSet, ...personalityResponses[npc.personality]];
            }
        }
        
        return responseSet[Math.floor(Math.random() * responseSet.length)];
    };
    
    const generateComment = (npcName, adultLevel = 0, playerText = "", optionType = "") => {
        const state = IntegratedGameState.getState();
        const npc = IntegratedGameState.getNPC(npcName);
        
        // Check cooldown (3 seconds between comments)
        const now = Date.now();
        const lastCommentTime = commentCooldowns.get(npcName) || 0;
        if (now - lastCommentTime < 3000) {
            return null; // Skip comment due to cooldown
        }
        commentCooldowns.set(npcName, now);
        
        // Get context from player's action
        const playerAction = playerText.toLowerCase();
        let contextAwareComment = "";
        
        // Generate context-aware comment based on player's dialog choice
        if (optionType === 'compliment' || playerAction.includes('compliment')) {
            contextAwareComment = getComplimentThought(npcName, npc?.baseMood || 50);
        } 
        else if (optionType === 'flirt' || playerAction.includes('flirt')) {
            contextAwareComment = getFlirtThought(npcName, npc?.relationship || 0);
        }
        else if (optionType === 'gift' || playerAction.includes('gift') || playerAction.includes('give')) {
            contextAwareComment = getGiftThought(npcName);
        }
        else if (playerAction.includes('drink')) {
            contextAwareComment = getDrinkThought(npcName);
        }
        else if (playerAction.includes('story') || playerAction.includes('tell')) {
            contextAwareComment = getStoryThought(npcName);
        }
        else {
            contextAwareComment = getGeneralThought(npcName, npc?.baseMood || 50);
        }
        
        // Add emotion flavor
        const emotion = EmotionSystem.getEmotion(npcName);
        if (emotion && Math.random() > 0.5) {
            return addEmotionToComment(contextAwareComment, emotion.current);
        }
        
        return contextAwareComment;
    };
    
    const getComplimentThought = (npcName, mood) => {
        const thoughts = {
            Eve: {
                high: ["That was actually a nice compliment.", "He's getting better at this.", "I might be starting to like him."],
                medium: ["Another compliment. Original.", "At least he's trying.", "Flattery will only get him so far."],
                low: ["Empty words.", "He thinks that'll work?", "Please."]
            },
            Jessica: {
                high: ["He's so sweet!", "I love compliments!", "He knows how to make me smile!"],
                medium: ["Nice compliment!", "He's trying!", "Cute!"],
                low: ["Meh.", "Could be better.", "Nice try."]
            },
            Danielle: {
                high: ["How romantic.", "He's quite charming.", "That was thoughtful."],
                medium: ["That was nice.", "Polite.", "Appropriate."],
                low: ["Unnecessary.", "Too forward.", "Let's keep it professional."]
            },
            Ashley: {
                high: ["Awesome compliment!", "He's cool!", "That made my day!"],
                medium: ["Nice!", "Cool!", "Thanks!"],
                low: ["Whatever.", "Okay.", "Sure."]
            },
            Nicole: {
                high: ["Interesting compliment.", "He's observant.", "Not bad."],
                medium: ["Acceptable.", "Fine.", "Okay."],
                low: ["Predictable.", "Boring.", "Next."]
            }
        };
        
        const npcThoughts = thoughts[npcName] || thoughts.Eve;
        let thoughtSet;
        
        if (mood > 70) thoughtSet = npcThoughts.high;
        else if (mood > 40) thoughtSet = npcThoughts.medium;
        else thoughtSet = npcThoughts.low;
        
        return thoughtSet[Math.floor(Math.random() * thoughtSet.length)];
    };
    
    const getFlirtThought = (npcName, relationship) => {
        const thoughts = {
            Eve: {
                high: ["He's being bold. I like that.", "Finally someone with confidence.", "This could get interesting..."],
                medium: ["Smooth move.", "He has courage.", "Interesting approach."],
                low: ["Too forward.", "Slow down, cowboy.", "Not so fast."]
            },
            Jessica: {
                high: ["Ooh, I like him!", "He's so smooth!", "This is getting fun!"],
                medium: ["Cheeky!", "He's funny!", "Nice try!"],
                low: ["Easy there!", "Whoa!", "Too fast!"]
            },
            Danielle: {
                high: ["My, my...", "He's being quite forward.", "This is unexpected."],
                medium: ["That's bold.", "Interesting.", "Hmm."],
                low: ["Inappropriate.", "Too much.", "Please stop."]
            },
            Ashley: {
                high: ["Haha, he's funny!", "I like his style!", "This is fun!"],
                medium: ["Cheeky!", "Bold!", "Hehe."],
                low: ["Whoa!", "Easy!", "Too soon!"]
            },
            Nicole: {
                high: ["Bold move. I respect that.", "He's not afraid.", "Interesting gamble."],
                medium: ["Risky.", "He has nerve.", "Interesting."],
                low: ["Too risky.", "Reckless.", "Poor judgment."]
            }
        };
        
        const npcThoughts = thoughts[npcName] || thoughts.Eve;
        let thoughtSet;
        
        if (relationship > 60) thoughtSet = npcThoughts.high;
        else if (relationship > 30) thoughtSet = npcThoughts.medium;
        else thoughtSet = npcThoughts.low;
        
        return thoughtSet[Math.floor(Math.random() * thoughtSet.length)];
    };
    
    const getGiftThought = (npcName) => {
        const thoughts = {
            Eve: ["A gift? How thoughtful.", "He's trying to impress me.", "Nice gesture."],
            Jessica: ["Ooh, a present! I love presents!", "How sweet of him!", "For me? Yay!"],
            Danielle: ["That's very kind of him.", "He's quite generous.", "A thoughtful gift."],
            Ashley: ["Awesome! A gift!", "He's so nice!", "Cool present!"],
            Nicole: ["A gift. Interesting strategy.", "He's trying to win favor.", "Acceptable."]
        };
        
        return thoughts[npcName]?.[Math.floor(Math.random() * thoughts[npcName].length)] || 
               "He gave me a gift.";
    };
    
    const getDrinkThought = (npcName) => {
        const thoughts = {
            Eve: ["A drink. At least he's polite.", "That was thoughtful.", "I needed that."],
            Jessica: ["Yay, drinks!", "He knows what I like!", "Cheers to that!"],
            Danielle: ["How gentlemanly.", "A thoughtful gesture.", "That was nice."],
            Ashley: ["Awesome! Free drink!", "He's cool!", "Sweet!"],
            Nicole: ["A drink. Standard move.", "Acceptable offer.", "Fine."]
        };
        
        return thoughts[npcName]?.[Math.floor(Math.random() * thoughts[npcName].length)] || 
               "He offered me a drink.";
    };
    
    const getStoryThought = (npcName) => {
        const thoughts = {
            Eve: ["He's opening up. Interesting.", "A personal story. Good move.", "Now we're getting somewhere."],
            Jessica: ["I love stories!", "He's sharing with me!", "This is getting personal!"],
            Danielle: ["How intimate.", "He's being vulnerable.", "That's beautiful."],
            Ashley: ["Cool story!", "He's interesting!", "Nice!"],
            Nicole: ["Interesting revelation.", "He's sharing information.", "Noted."]
        };
        
        return thoughts[npcName]?.[Math.floor(Math.random() * thoughts[npcName].length)] || 
               "He told me a story.";
    };
    
    const getGeneralThought = (npcName, mood) => {
        const thoughts = {
            Eve: {
                high: ["He's not like the others.", "I'm actually enjoying this.", "This might be worth my time."],
                medium: ["Another conversation.", "Let's see where this goes.", "He's trying."],
                low: ["How much longer?", "This is getting old.", "Not impressed."]
            },
            Jessica: {
                high: ["This is fun!", "I like talking to him!", "He's awesome!"],
                medium: ["Nice chat!", "Good conversation!", "Having fun!"],
                low: ["Okay, I guess.", "Whatever.", "Fine."]
            },
            Danielle: {
                high: ["What a pleasant conversation.", "He's quite charming.", "This is nice."],
                medium: ["Polite conversation.", "Acceptable.", "Fine."],
                low: ["I should get back to work.", "This is dragging.", "Enough."]
            },
            Ashley: {
                high: ["Awesome conversation!", "He's cool!", "Having a blast!"],
                medium: ["Nice talk!", "Good times!", "Cool!"],
                low: ["Okay then.", "Sure.", "Uh huh."]
            },
            Nicole: {
                high: ["Intriguing conversation.", "He's interesting.", "This has potential."],
                medium: ["Acceptable dialogue.", "Fine.", "Proceed."],
                low: ["Time is money.", "Get to the point.", "Boring."]
            }
        };
        
        const npcThoughts = thoughts[npcName] || thoughts.Eve;
        let thoughtSet;
        
        if (mood > 70) thoughtSet = npcThoughts.high;
        else if (mood > 40) thoughtSet = npcThoughts.medium;
        else thoughtSet = npcThoughts.low;
        
        return thoughtSet[Math.floor(Math.random() * thoughtSet.length)];
    };
    
    const addEmotionToComment = (comment, emotion) => {
        const emotionModifiers = {
            joy: ["So happy about ", "Excited that ", "Thrilled "],
            anger: ["Annoyed that ", "Frustrated with ", "Upset about "],
            trust: ["Glad I can trust ", "Happy to open up to ", "Comfortable with "],
            anticipation: ["Curious about ", "Interested in ", "Wondering about "],
            sadness: ["Disappointed with ", "Sad about ", "Regretting "],
            disgust: ["Disgusted by ", "Revolted by ", "Appalled at "],
            fear: ["Worried about ", "Concerned by ", "Nervous of "],
            surprise: ["Surprised by ", "Shocked at ", "Amazed by "]
        };
        
        if (emotionModifiers[emotion] && Math.random() > 0.5) {
            const modifier = emotionModifiers[emotion][Math.floor(Math.random() * emotionModifiers[emotion].length)];
            return modifier + comment.toLowerCase();
        }
        
        return comment;
    };
    
    return {
        getResponse,
        generateComment,
        setAIMode,
        getAIMode
    };
})();

// ===== INTEGRATED QUEST MANAGER (Enhanced) =====
const IntegratedQuestManager = (() => {
    const updateQuestProgress = (questId, amount) => {
        const quests = IntegratedGameState.getQuests();
        const quest = quests.find(q => q.id === questId);
        const state = IntegratedGameState.getState();
        
        if (quest && !quest.completed) {
            // Skip enhanced quests if not in enhanced mode
            if (quest.enhanced && !state.enhancedMode) return;
            
            let actualAmount = amount;
            
            if (questId === 1) { // "Get Eve's attention" quest
                const npc = IntegratedGameState.getNPC('Eve');
                
                if (npc && (npc.relationship > 40 || state.mood > 70)) {
                    actualAmount = Math.max(amount, 30);
                }
                
                if (state.relationship > 50) {
                    actualAmount = 100;
                }
            }
            
            // Apply emotion modifier
            if (state.enhancedMode && state.currentNPC) {
                const emotionModifier = EmotionSystem.getEmotionModifier(state.currentNPC, 'mood');
                actualAmount = Math.floor(actualAmount * emotionModifier);
            }
            
            const oldProgress = quest.progress;
            quest.progress = Math.min(100, Math.max(0, quest.progress + actualAmount));
            
            if (quest.progress !== oldProgress) {
                IntegratedUIManager.updateQuestTracker();
                
                if (actualAmount >= 10) {
                    IntegratedUIManager.showNotification(`Quest Progress: ${quest.name} (${quest.progress}%)`);
                }
                
                if (quest.progress >= 100) {
                    completeQuest(questId);
                }
            }
        }
    };
    
    const completeQuest = (questId) => {
        const quests = IntegratedGameState.getQuests();
        const quest = quests.find(q => q.id === questId);
        const state = IntegratedGameState.getState();
        
        if (quest && !quest.completed) {
            quest.completed = true;
            IntegratedGameState.setState({
                score: state.score + quest.reward,
                questsCompleted: state.questsCompleted + 1
            });
            
            // Animate quest completion
            const questBar = IntegratedUIManager.elements.questBar;
            questBar.style.animation = 'pulse 0.5s 3';
            
            IntegratedUIManager.showNotification(`üéâ Quest Completed: ${quest.name}! +${quest.reward} points`, 'success');
            
            // Find next quest
            const nextQuestIndex = quests.findIndex(q => !q.completed && (!q.enhanced || state.enhancedMode));
            
            setTimeout(() => {
                questBar.style.animation = '';
                questBar.style.transition = 'none';
                questBar.style.width = '0%';
                
                if (nextQuestIndex !== -1) {
                    IntegratedGameState.setState({ currentQuest: nextQuestIndex });
                    
                    setTimeout(() => {
                        const nextQuest = quests[nextQuestIndex];
                        if (nextQuest) {
                            questBar.style.transition = 'width 1.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
                            questBar.style.width = `${nextQuest.progress}%`;
                        }
                    }, 50);
                }
                
                IntegratedUIManager.updateQuestTracker();
            }, 1500);
            
            updateOverallProgress();
            IntegratedUIManager.updateStats();
            
            // Check achievements
            AchievementSystem.checkAchievement('first_meeting');
            
            // Special celebrations
            if (questId === 1) {
                IntegratedUIManager.addMessage('Eve: Well, you definitely have my attention now! What\'s next?', 'npc');
                IntegratedGameState.addComment({
                    npc: 'Eve',
                    text: 'He actually did it. He got my full attention. Now I\'m curious...',
                    time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    adult: false
                });
                IntegratedUIManager.renderComments();
            }
            
            if (questId === 2) {
                IntegratedUIManager.addMessage('Eve: Thanks for the drink! That was sweet of you.', 'npc');
            }
            
            if (questId === 6) {
                IntegratedUIManager.addMessage('Eve: That was... amazing.', 'npc', true);
                IntegratedGameState.addComment({
                    npc: 'Eve',
                    text: 'I think I might actually like this guy...',
                    time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    adult: true
                });
                IntegratedUIManager.renderComments();
            }
            
            // Enhanced quest completions
            if (questId === 7) { // Meet All NPCs
                IntegratedUIManager.showNotification('üèÜ All NPCs encountered! Social butterfly achievement unlocked!', 'adult');
                AchievementSystem.checkAchievement('social_butterfly');
            }
            
            if (questId === 9) { // True Love
                const npc = IntegratedGameState.getNPC(IntegratedGameState.getState().currentNPC);
                if (npc) {
                    IntegratedGameState.unlockEnding(npc.name, 'perfect');
                    IntegratedUIManager.showNotification(`üéâ Perfect Ending Unlocked with ${npc.name}!`, 'adult');
                }
            }
            
            if (questId === 11) { // Story Teller
                IntegratedUIManager.showNotification('üìñ Story Teller achievement progress!', 'success');
            }
            
            if (questId === 12) { // Emotion Master
                IntegratedUIManager.showNotification('üíñ Emotion Master achievement progress!', 'success');
            }
        }
    };
    
    const updateOverallProgress = () => {
        const state = IntegratedGameState.getState();
        const quests = IntegratedGameState.getQuests();
        // Only count quests that are available in current mode
        const availableQuests = quests.filter(q => !q.enhanced || state.enhancedMode);
        const completedQuests = availableQuests.filter(q => q.completed).length;
        const totalQuests = availableQuests.length;
        
        const progress = totalQuests > 0 ? Math.floor((completedQuests / totalQuests) * 100) : 0;
        IntegratedGameState.setState({ progress });
        
        IntegratedUIManager.elements.progressValue.textContent = `${progress}%`;
        
        // Visual feedback for milestone achievements
        if (progress > 0 && progress % 25 === 0) {
            const progressElement = IntegratedUIManager.elements.progressValue;
            progressElement.style.transform = 'scale(1.3)';
            progressElement.style.color = 'var(--warning)';
            setTimeout(() => {
                progressElement.style.transform = 'scale(1)';
                progressElement.style.color = '';
            }, 500);
            
            if (progress === 25) {
                IntegratedUIManager.showNotification('üèÜ 25% Progress! Keep going!', 'success');
            } else if (progress === 50) {
                IntegratedUIManager.showNotification('üèÜ 50% Progress! Halfway there!', 'warning');
            } else if (progress === 75) {
                IntegratedUIManager.showNotification('üèÜ 75% Progress! Almost there!', 'success');
            } else if (progress === 100) {
                IntegratedUIManager.showNotification('üéâ 100% Progress! All quests completed!', 'adult');
            }
        }
    };
    
    return {
        updateQuestProgress,
        completeQuest,
        updateOverallProgress
    };
})();

// ===== DATE SYSTEM =====
const DateSystem = (() => {
    const setupDateListeners = () => {
        // Date scheduler events
        document.getElementById('date-npc-select').addEventListener('click', (e) => {
            const option = e.target.closest('.date-option');
            if (option && option.dataset.npc) {
                document.querySelectorAll('#date-npc-select .date-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                option.classList.add('selected');
            }
        });
        
        document.getElementById('date-location-select').addEventListener('click', (e) => {
            const option = e.target.closest('.date-option');
            if (option && option.dataset.location) {
                document.querySelectorAll('#date-location-select .date-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                option.classList.add('selected');
            }
        });
        
        // Time selection
        document.getElementById('date-time-select')?.addEventListener('click', (e) => {
            const option = e.target.closest('.date-time-option');
            if (option) {
                document.querySelectorAll('#date-time-select .date-time-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                option.classList.add('selected');
            }
        });
        
        document.getElementById('confirm-date').addEventListener('click', () => {
            const selectedNPC = document.querySelector('#date-npc-select .date-option.selected');
            const selectedLocation = document.querySelector('#date-location-select .date-option.selected');
            const selectedTime = document.querySelector('#date-time-select .date-time-option.selected');
            
            if (selectedNPC && selectedLocation) {
                const npcName = selectedNPC.dataset.npc;
                const locationId = selectedLocation.dataset.location;
                const time = selectedTime ? selectedTime.textContent : 'evening';
                
                IntegratedGameState.scheduleDate(npcName, locationId, time);
                IntegratedUIManager.elements.dateScheduler.style.display = 'none';
                IntegratedUIManager.showNotification(`Date scheduled with ${npcName}!`);
                
                // Start date immediately
                setTimeout(() => {
                    showDateScene(npcName, locationId);
                }, 1000);
            } else {
                IntegratedUIManager.showNotification('Please select both an NPC and a location!', 'warning');
            }
        });
        
        document.getElementById('cancel-date').addEventListener('click', () => {
            IntegratedUIManager.elements.dateScheduler.style.display = 'none';
        });
        
        // Date scene events
        document.getElementById('date-content').addEventListener('click', (e) => {
            const choice = e.target.closest('.date-choice');
            if (choice && choice.dataset.choice) {
                handleDateChoice(choice.dataset.choice);
            }
            
            if (e.target.id === 'end-date') {
                IntegratedUIManager.elements.dateScene.style.display = 'none';
                IntegratedUIManager.showNotification('Date completed successfully!');
                
                // Update Multiple Dates quest
                IntegratedQuestManager.updateQuestProgress(8, 33);
                
                // Check achievement
                AchievementSystem.checkAchievement('multi_dater');
            }
        });
    };
    
    const showDateScene = (npcName, locationId) => {
        const npc = IntegratedGameState.getNPC(npcName);
        const location = IntegratedGameState.getLocation(locationId);
        
        if (npc && location) {
            document.getElementById('date-background').style.background = location.dateBackground;
            document.getElementById('date-content').innerHTML = `
                <h2>Date with ${npc.name}</h2>
                <div class="date-npc-dialogue">
                    "${getDateDialogue(npc, location)}"
                </div>
                <div class="date-choices">
                    <div class="date-choice" data-choice="compliment">Compliment her</div>
                    <div class="date-choice" data-choice="gift">Give a gift</div>
                    <div class="date-choice" data-choice="flirt">Flirt subtly</div>
                    <div class="date-choice" data-choice="story">Share a story</div>
                </div>
            `;
            
            IntegratedUIManager.elements.dateScene.style.display = 'flex';
        }
    };
    
    const getDateDialogue = (npc, location) => {
        const dialogues = {
            Eve: `I'm glad we could meet here at the ${location.name}. It's... nicer than I expected.`,
            Jessica: `Ooh, I love the ${location.name}! This is going to be fun!`,
            Danielle: `The ${location.name} is so beautiful tonight. Thank you for inviting me.`,
            Ashley: `Wow, the ${location.name}! Perfect choice for a date!`,
            Nicole: `The ${location.name}... interesting choice. Let's see where this goes.`
        };
        
        return dialogues[npc.name] || `Thanks for meeting me here at the ${location.name}.`;
    };
    
    const handleDateChoice = (choice) => {
        const state = IntegratedGameState.getState();
        const npc = IntegratedGameState.getNPC(state.currentNPC);
        
        if (!npc) return;
        
        let result = '';
        let moodChange = 0;
        let relationshipChange = 0;
        
        switch(choice) {
            case 'compliment':
                result = `"You're too kind!"`;
                moodChange = 15;
                relationshipChange = 8;
                EmotionSystem.influenceEmotion(npc.name, 'joy', 10);
                break;
            case 'gift':
                result = `"Another gift? You're spoiling me!"`;
                moodChange = 25;
                relationshipChange = 15;
                EmotionSystem.influenceEmotion(npc.name, 'trust', 15);
                break;
            case 'flirt':
                result = `*giggles* "You're being naughty..."`;
                moodChange = 20;
                relationshipChange = 12;
                EmotionSystem.influenceEmotion(npc.name, 'anticipation', 12);
                break;
            case 'story':
                result = `"That's a beautiful story. Thank you for sharing."`;
                moodChange = 18;
                relationshipChange = 10;
                EmotionSystem.influenceEmotion(npc.name, 'trust', 10);
                break;
        }
        
        // Update NPC
        IntegratedGameState.updateNPC(npc.name, {
            baseMood: Math.min(100, npc.baseMood + moodChange),
            relationship: npc.relationship + relationshipChange
        });
        
        // Update global state
        IntegratedGameState.setState({
            mood: Math.min(100, state.mood + moodChange),
            relationship: state.relationship + relationshipChange,
            score: state.score + 100
        });
        
        // Show result
        const dateContent = document.getElementById('date-content');
        dateContent.innerHTML += `
            <div class="date-npc-dialogue">${npc.name}: ${result}</div>
            <button class="btn btn-success" id="end-date">End Date</button>
        `;
        
        IntegratedUIManager.updateStats();
        
        // Check for ending unlock
        if (npc.relationship + relationshipChange >= 100) {
            IntegratedGameState.unlockEnding(npc.name, 'perfect');
            IntegratedUIManager.showNotification(`üéâ Perfect Ending Unlocked with ${npc.name}!`, 'adult');
        }
    };
    
    return {
        setupDateListeners
    };
})();

// ===== ENDINGS SYSTEM =====
const EndingsSystem = (() => {
    const setupEndingsListeners = () => {
        document.getElementById('endings-btn').addEventListener('click', () => {
            IntegratedUIManager.elements.endingGallery.style.display = 'block';
            renderEndingsGallery();
        });
        
        document.getElementById('close-endings').addEventListener('click', () => {
            IntegratedUIManager.elements.endingGallery.style.display = 'none';
        });
    };
    
    const renderEndingsGallery = () => {
        const container = document.getElementById('endings-container');
        const state = IntegratedGameState.getState();
        
        if (state.unlockedEndings.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary)">No endings unlocked yet! Complete relationships to unlock endings.</div>';
            return;
        }
        
        container.innerHTML = '';
        state.unlockedEndings.forEach(endingId => {
            const [npcName, endingType] = endingId.split('_');
            const npc = IntegratedGameState.getNPC(npcName);
            
            const endingCard = document.createElement('div');
            endingCard.className = 'ending-card';
            
            const endingTitles = {
                perfect: 'Perfect Romance',
                good: 'Happy Together',
                bad: 'Bitter End',
                neutral: 'Friends Forever'
            };
            
            endingCard.innerHTML = `
                <h3 class="ending-title">${endingTitles[endingType] || 'Special Ending'}</h3>
                <div class="ending-npc">
                    <div class="relationship-avatar" style="background: ${npc.color}">${npc.emoji}</div>
                    <div>
                        <div class="relationship-name">${npc.name}</div>
                        <div class="relationship-location">${endingType} Ending</div>
                    </div>
                </div>
                <div class="ending-description">
                    ${getEndingDescription(npcName, endingType)}
                </div>
                <div class="ending-requirements">
                    <strong>Requirements:</strong> Reach 100 relationship with ${npc.name}
                </div>
            `;
            
            container.appendChild(endingCard);
        });
    };
    
    const getEndingDescription = (npcName, endingType) => {
        const descriptions = {
            perfect: `You and ${npcName} found true love together. What started as a casual encounter blossomed into something beautiful and lasting. You both live happily ever after.`,
            good: `You and ${npcName} developed a strong bond. While not perfect, your relationship brings joy to both of your lives.`,
            neutral: `You and ${npcName} remained good friends. The romance didn't work out, but you found value in each other's company.`,
            bad: `Things didn't work out with ${npcName}. Maybe it was timing, maybe it was chemistry... but this story ends here.`
        };
        
        return descriptions[endingType] || `You reached a special ending with ${npcName}.`;
    };
    
    return {
        setupEndingsListeners,
        renderEndingsGallery
    };
})();

// ===== INTEGRATED GAME ENGINE (Enhanced) =====
const IntegratedGameEngine = (() => {
    let gameTimer;
    
    const init = () => {
        IntegratedUIManager.initialize();
        
        // Initialize AI system
        IntegratedNPCAI.setAIMode(IntegratedGameState.getState().aiMode);
        
        // Age verification
        document.getElementById('age-confirm').addEventListener('click', () => {
            IntegratedGameState.setState({
                ageVerified: true,
                adultMode: true
            });
            
            IntegratedUIManager.showLoading('Initializing game...');
            
            setTimeout(() => {
                IntegratedUIManager.elements.ageGate.style.display = 'none';
                IntegratedUIManager.elements.gameContainer.style.display = 'block';
                IntegratedUIManager.elements.gameContainer.setAttribute('aria-hidden', 'false');
                IntegratedUIManager.elements.adultIndicator.style.display = 'block';
                
                // Add adult items only if adult mode is enabled
                const state = IntegratedGameState.getState();
                if (state.adultMode) {
                    const newInventory = [...state.inventory, 'ticket'];
                    // Only add condom if we have any
                    if (IntegratedGameState.getCondomCount() > 0) {
                        newInventory.push('condom');
                    }
                    IntegratedGameState.setState({ inventory: newInventory });
                }
                
                IntegratedUIManager.hideLoading();
                IntegratedUIManager.showNotification('Adult Mode Enabled! Welcome to the full experience!', 'adult');
                startGame();
            }, 1000);
        });
        
        document.getElementById('age-deny').addEventListener('click', () => {
            IntegratedGameState.setState({
                ageVerified: true,
                adultMode: false
            });
            
            IntegratedUIManager.showLoading('Initializing game...');
            
            setTimeout(() => {
                IntegratedUIManager.elements.ageGate.style.display = 'none';
                IntegratedUIManager.elements.gameContainer.style.display = 'block';
                IntegratedUIManager.elements.gameContainer.setAttribute('aria-hidden', 'false');
                
                IntegratedUIManager.hideLoading();
                IntegratedUIManager.showNotification('Standard Mode Enabled. Some content may be restricted.');
                startGame();
            }, 1000);
        });
    };
    
    const startGame = () => {
        try {
            IntegratedUIManager.updateStats();
            IntegratedSceneManager.renderScene();
            IntegratedSceneManager.renderMiniMap();
            IntegratedInventoryManager.renderInventory();
            
            // Start condom restock system
            IntegratedGameState.startCondomRestockSystem();
            
            // Initialize emotion system
            EmotionSystem.initializeEmotionWheel();
            
            // Initialize story progress for current NPC
            const state = IntegratedGameState.getState();
            EmotionSystem.setEmotion(state.currentNPC, 'anticipation', 50);
            
            // Initial message
            IntegratedUIManager.addMessage('Eve: Another night, another hopeful romantic. Make it interesting.', 'npc');
            
            IntegratedGameState.addComment({
                npc: 'Eve',
                text: 'I wonder if this one will actually say something original for once.',
                time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                adult: false
            });
            IntegratedUIManager.renderComments();
            
            IntegratedDialogManager.updateDialogOptions();
            startGameTimer();
            setupEventListeners();
            
            IntegratedUIManager.elements.questTracker.style.display = 'block';
            IntegratedQuestManager.updateOverallProgress();
            IntegratedUIManager.updateQuestTracker();
        } catch (error) {
            console.error('Game initialization error:', error);
            IntegratedUIManager.showNotification('Game initialization failed! Please refresh.', 'error');
        }
    };
    
    const startGameTimer = () => {
        clearInterval(gameTimer);
        gameTimer = setInterval(() => {
            const state = IntegratedGameState.getState();
            IntegratedGameState.setState({ time: state.time + 1 });
            
            const minutes = Math.floor(state.time / 60);
            const seconds = state.time % 60;
            IntegratedUIManager.elements.timeValue.textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update mood every minute
            if (state.time % 60 === 0) {
                const newMood = Math.max(0, state.mood - 1);
                IntegratedGameState.setState({ mood: newMood });
                IntegratedUIManager.updateStats();
            }
            
            // Update achievements periodically
            if (state.time % 30 === 0) {
                AchievementSystem.checkAllAchievements();
            }
        }, 1000);
    };
    
    const setupEventListeners = () => {
        // Action buttons (original)
        IntegratedUIManager.addEventListener('look-btn', 'click', () => {
            IntegratedUIManager.addMessage('Larry: *Looks around the room*', 'player');
            IntegratedGameState.addComment({
                npc: IntegratedGameState.getState().currentNPC,
                text: 'He\'s looking around like a lost puppy.',
                time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                adult: false
            });
            IntegratedUIManager.renderComments();
            IntegratedQuestManager.updateQuestProgress(1, 5);
        });
        
        IntegratedUIManager.addEventListener('talk-btn', 'click', () => {
            IntegratedDialogManager.updateDialogOptions();
            IntegratedUIManager.showNotification('Dialog options updated!');
        });
        
        IntegratedUIManager.elements.useBtn.addEventListener('click', () => {
            IntegratedItemUseHandler.useSelectedItem();
        });
        
        IntegratedUIManager.addEventListener('move-btn', 'click', () => {
            const state = IntegratedGameState.getState();
            const locations = IntegratedGameState.getLocations();
            const currentIndex = locations.findIndex(loc => loc.id === state.currentLocation);
            let nextIndex = (currentIndex + 1) % locations.length;
            
            // Skip locked locations
            while (locations[nextIndex]?.locked) {
                nextIndex = (nextIndex + 1) % locations.length;
                if (nextIndex === currentIndex) break;
            }
            
            // Scene transition effect
            const transition = document.getElementById('scene-transition');
            transition.style.opacity = '1';
            
            setTimeout(() => {
                IntegratedGameState.setState({ currentLocation: locations[nextIndex].id });
                IntegratedUIManager.showNotification(`Moved to: ${locations[nextIndex].name}`);
                IntegratedSceneManager.renderScene();
                IntegratedSceneManager.renderMiniMap();
                
                IntegratedGameState.addComment({
                    npc: state.currentNPC,
                    text: 'He moved to a different location. Persistent, I\'ll give him that.',
                    time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    adult: false
                });
                IntegratedUIManager.renderComments();
                
                IntegratedDialogManager.updateDialogOptions();
                
                // Fade out transition
                transition.style.opacity = '0';
            }, 300);
        });
        
        IntegratedUIManager.addEventListener('examine-btn', 'click', () => {
            const state = IntegratedGameState.getState();
            const examineTexts = {
                bar: "The bar is dimly lit with a sophisticated atmosphere. There's a jukebox in the corner playing soft jazz. Several interesting items are scattered around.",
                hotel: "The hotel lobby is luxurious with marble floors. The reception desk looks expensive. You notice some items on the tables.",
                beach: "The beach is beautiful with golden sand. The sunset creates a romantic atmosphere. Various beach items are visible.",
                casino: "The casino is bustling with activity. Slot machines ring and cards shuffle. There might be useful items around.",
                hotelRoom: "The suite is spacious with a king-size bed and a balcony overlooking the city. Romantic items are placed around the room."
            };
            
            IntegratedUIManager.addMessage(`Larry: ${examineTexts[state.currentLocation] || "It's an interesting place."}`, 'player');
            IntegratedGameState.addComment({
                npc: state.currentNPC,
                text: 'He\'s examining the surroundings. At least he\'s observant.',
                time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                adult: false
            });
            IntegratedUIManager.renderComments();
            IntegratedQuestManager.updateQuestProgress(1, 10);
        });
        
        IntegratedUIManager.addEventListener('flirt-btn', 'click', () => {
            const state = IntegratedGameState.getState();
            if (!state.adultMode) {
                IntegratedUIManager.showNotification('Flirt mode requires Adult Mode to be enabled!', 'warning');
                return;
            }
            
            const flirtLines = [
                "Your eyes are like deep pools I could swim in... all night.",
                "Is it hot in here, or is it just you?",
                "I'm not a photographer, but I can picture us together.",
                "Do you believe in love at first sight, or should I walk by again?",
                "If you were a fruit, you'd be a fine-apple."
            ];
            
            const flirtLine = flirtLines[Math.floor(Math.random() * flirtLines.length)];
            IntegratedUIManager.addMessage(`Larry: ${flirtLine}`, 'player', true);
            
            setTimeout(() => {
                if (state.relationship > 40) {
                    const responses = IntegratedNPCAI.getAIMode() ? [
                        "*giggles* Smooth, very smooth.",
                        "Okay, that was actually good.",
                        "You're charming, I'll give you that.",
                        "Keep talking like that and you might just get somewhere."
                    ] : [
                        "That's nice.",
                        "Thank you.",
                        "I appreciate that.",
                        "That's interesting."
                    ];
                    IntegratedUIManager.addMessage(`${state.currentNPC}: ${responses[Math.floor(Math.random() * responses.length)]}`, 'npc', true);
                    const newMood = Math.min(100, state.mood + 15);
                    const newRelationship = state.relationship + 10;
                    IntegratedGameState.setState({
                        mood: newMood,
                        relationship: newRelationship
                    });
                    IntegratedQuestManager.updateQuestProgress(6, 10);
                    IntegratedQuestManager.updateQuestProgress(1, 20);
                    
                    // Update emotion
                    EmotionSystem.influenceEmotion(state.currentNPC, 'joy', 15);
                } else {
                    IntegratedUIManager.addMessage(`${state.currentNPC}: Seriously? Try harder.`, 'npc');
                    const newMood = Math.max(0, state.mood - 10);
                    IntegratedGameState.setState({ mood: newMood });
                    EmotionSystem.influenceEmotion(state.currentNPC, 'anger', 10);
                }
                IntegratedUIManager.updateStats();
            }, 500);
        });
        
        IntegratedUIManager.addEventListener('quest-info-btn', 'click', () => {
            const state = IntegratedGameState.getState();
            const currentQuest = IntegratedGameState.getCurrentQuest();
            const allQuests = IntegratedGameState.getQuests();
            
            let info = `=== QUEST PROGRESS ===\n`;
            info += `Overall: ${state.progress}%\n`;
            info += `Quests Completed: ${state.questsCompleted}/${allQuests.filter(q => !q.enhanced || state.enhancedMode).length}\n\n`;
            
            info += `CURRENT QUEST:\n`;
            info += `‚Üí ${currentQuest.name}\n`;
            info += `Progress: ${currentQuest.progress}%\n`;
            info += `Objective: ${currentQuest.objective || currentQuest.description}\n`;
            info += `Reward: ${currentQuest.reward} points\n\n`;
            
            info += `UPCOMING QUESTS:\n`;
            allQuests.forEach((quest, index) => {
                if ((!quest.enhanced || state.enhancedMode) && index >= state.currentQuest && index < state.currentQuest + 3) {
                    const status = quest.completed ? '‚úì' : index === state.currentQuest ? '‚Üí' : '‚óã';
                    info += `${status} ${quest.name} ${quest.adult ? '(18+)' : ''} ${quest.enhanced ? '[Enhanced]' : ''}\n`;
                }
            });
            
            alert(info);
        });
        
        // Enhanced mode toggle
        IntegratedUIManager.elements.enhancedModeToggle.addEventListener('click', () => {
            IntegratedUIManager.toggleEnhancedMode();
        });
        
        // NPC selector toggle
        IntegratedUIManager.addEventListener('npc-selector-toggle-btn', 'click', () => {
            const panel = IntegratedUIManager.elements.npcSelectorPanel;
            
            // Always allow NPC switching, but show different options
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            if (panel.style.display === 'block') {
                IntegratedUIManager.renderNPCSelector();
            }
        });
        
        // Relationships button
        IntegratedUIManager.addEventListener('relationships-btn', 'click', () => {
            const panel = IntegratedUIManager.elements.relationshipsPanel;
            const state = IntegratedGameState.getState();
            
            if (!state.enhancedMode) {
                IntegratedUIManager.showNotification('Enable Enhanced Mode to view relationships!', 'warning');
                return;
            }
            
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            if (panel.style.display === 'block') {
                IntegratedUIManager.renderRelationships();
            }
        });
        
        // Date button
        IntegratedUIManager.addEventListener('date-btn', 'click', () => {
            const state = IntegratedGameState.getState();
            
            if (!state.enhancedMode) {
                IntegratedUIManager.showNotification('Enable Enhanced Mode to schedule dates!', 'warning');
                return;
            }
            
            IntegratedUIManager.showDateScheduler();
        });
        
        // NEW: Buy condoms button
        IntegratedUIManager.addEventListener('buy-condoms-btn', 'click', () => {
            const state = IntegratedGameState.getState();
            
            if (!state.adultMode) {
                IntegratedUIManager.showNotification('Adult Mode required to buy protection!', 'warning');
                return;
            }
            
            const location = IntegratedGameState.getLocation(state.currentLocation);
            
            // Check if can buy condoms here (bar, hotel, casino)
            const canBuyHere = ['bar', 'hotel', 'casino'].includes(state.currentLocation);
            
            if (!canBuyHere) {
                IntegratedUIManager.showNotification('Can only buy protection at the bar, hotel, or casino!', 'warning');
                return;
            }
            
            if (state.score < 50) {
                IntegratedUIManager.showNotification(`Need $50 to buy protection! You have $${state.score}.`, 'error');
                return;
            }
            
            if (IntegratedGameState.getCondomCount() >= 5) {
                IntegratedUIManager.showNotification('Already have maximum protection (5)!', 'warning');
                return;
            }
            
            // Buy condoms
            IntegratedGameState.restockCondom();
            IntegratedGameState.setState({ score: state.score - 50 });
            
            IntegratedUIManager.addMessage(`Larry: *Buys protection* Always be prepared!`, 'player', true);
            IntegratedUIManager.showNotification(`‚úÖ Bought protection! Now have ${IntegratedGameState.getCondomCount()}. -$50`, 'success');
            IntegratedUIManager.updateStats();
            IntegratedInventoryManager.renderInventory();
        });
        
        // NEW: Achievements button
        IntegratedUIManager.addEventListener('achievements-btn', 'click', () => {
            const panel = IntegratedUIManager.elements.achievementsPanel;
            const state = IntegratedGameState.getState();
            
            if (!state.enhancedMode) {
                IntegratedUIManager.showNotification('Enable Enhanced Mode to view achievements!', 'warning');
                return;
            }
            
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            if (panel.style.display === 'block') {
                AchievementSystem.renderAchievements();
            }
        });
        
        // NEW: Analytics button
        IntegratedUIManager.addEventListener('analytics-btn', 'click', () => {
            const panel = IntegratedUIManager.elements.analyticsPanel;
            const state = IntegratedGameState.getState();
            
            if (!state.enhancedMode) {
                IntegratedUIManager.showNotification('Enable Enhanced Mode to view analytics!', 'warning');
                return;
            }
            
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            if (panel.style.display === 'block') {
                AnalyticsSystem.renderRelationshipGraph();
            }
        });
        
        // NEW: Story button
        IntegratedUIManager.addEventListener('story-btn', 'click', () => {
            const panel = IntegratedUIManager.elements.storyEnginePanel;
            const state = IntegratedGameState.getState();
            
            if (!state.enhancedMode) {
                IntegratedUIManager.showNotification('Enable Enhanced Mode to view story progress!', 'warning');
                return;
            }
            
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            if (panel.style.display === 'block') {
                StoryEngine.renderStoryProgress();
            }
        });
        
        // NEW: Mini-game button
        IntegratedUIManager.addEventListener('mini-game-btn', 'click', () => {
            const state = IntegratedGameState.getState();
            
            if (!state.enhancedMode) {
                IntegratedUIManager.showNotification('Enable Enhanced Mode to play mini-games!', 'warning');
                return;
            }
            
            MiniGameSystem.startMiniGame('poker');
        });
        
        // Save/Load/Reset buttons
        IntegratedUIManager.addEventListener('save-btn', 'click', () => {
            try {
                const saveData = {
                    state: IntegratedGameState.getState(),
                    npcs: IntegratedGameState.getNPCs(),
                    quests: IntegratedGameState.getQuests(),
                    collectedItems: IntegratedGameState.getState().collectedItems,
                    emotionMemory: (() => {
                        const result = {};
                        const npcs = IntegratedGameState.getNPCs();
                        Object.keys(npcs).forEach(npcName => {
                            const emotion = EmotionSystem.getEmotion(npcName);
                            if (emotion) result[npcName] = emotion;
                        });
                        return result;
                    })()
                };
                localStorage.setItem('larryEnhancedGameSave', JSON.stringify(saveData));
                IntegratedUIManager.showNotification('Game saved successfully!');
                IntegratedGameState.addComment({
                    npc: IntegratedGameState.getState().currentNPC,
                    text: 'He saved the game. Not confident about his chances?',
                    time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    adult: false
                });
                IntegratedUIManager.renderComments();
            } catch (error) {
                IntegratedUIManager.showNotification('Failed to save game!', 'error');
            }
        });
        
        IntegratedUIManager.addEventListener('load-btn', 'click', () => {
            try {
                const savedGame = localStorage.getItem('larryEnhancedGameSave');
                if (savedGame) {
                    const saveData = JSON.parse(savedGame);
                    
                    // Load state
                    IntegratedGameState.setState(saveData.state);
                    
                    // Load NPCs
                    Object.keys(saveData.npcs).forEach(npcName => {
                        IntegratedGameState.updateNPC(npcName, saveData.npcs[npcName]);
                    });
                    
                    // Load quests
                    saveData.quests.forEach((savedQuest, index) => {
                        const quests = IntegratedGameState.getQuests();
                        if (quests[index]) {
                            quests[index].progress = savedQuest.progress;
                            quests[index].completed = savedQuest.completed;
                        }
                    });
                    
                    // Load emotion memory
                    if (saveData.emotionMemory) {
                        Object.entries(saveData.emotionMemory).forEach(([npcName, emotion]) => {
                            EmotionSystem.setEmotion(npcName, emotion.current, emotion.intensity);
                        });
                    }
                    
                    // Update AI mode
                    IntegratedNPCAI.setAIMode(saveData.state.aiMode);
                    
                    // Restart condom restock system
                    IntegratedGameState.stopCondomRestockSystem();
                    IntegratedGameState.startCondomRestockSystem();
                    
                    // Update UI
                    IntegratedUIManager.updateStats();
                    IntegratedSceneManager.renderScene();
                    IntegratedSceneManager.renderMiniMap();
                    IntegratedInventoryManager.renderInventory();
                    IntegratedUIManager.updateCurrentNPC();
                    
                    if (saveData.state.enhancedMode) {
                        IntegratedUIManager.elements.enhancedIndicator.style.display = 'block';
                        IntegratedUIManager.elements.enhancedModeText.textContent = 'Disable Enhanced Mode';
                        IntegratedUIManager.elements.npcDialogIndicator.style.display = 'flex';
                        IntegratedUIManager.renderNPCSelector();
                        IntegratedUIManager.renderRelationships();
                    }
                    
                    IntegratedUIManager.showNotification('Game loaded successfully!');
                    IntegratedGameState.addComment({
                        npc: IntegratedGameState.getState().currentNPC,
                        text: 'He loaded a previous save. Trying to undo mistakes?',
                        time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                        adult: false
                    });
                    IntegratedUIManager.renderComments();
                } else {
                    IntegratedUIManager.showNotification('No saved game found!', 'warning');
                }
            } catch (error) {
                IntegratedUIManager.showNotification('Failed to load game!', 'error');
            }
        });
        
        IntegratedUIManager.addEventListener('reset-btn', 'click', () => {
            if (confirm('Are you sure you want to reset the game? All progress will be lost!')) {
                localStorage.removeItem('larryEnhancedGameSave');
                location.reload();
            }
        });
        
        // AI toggle
        IntegratedUIManager.addEventListener('ai-toggle', 'click', () => {
            const state = IntegratedGameState.getState();
            const newAiMode = !state.aiMode;
            IntegratedGameState.setState({ aiMode: newAiMode });
            IntegratedNPCAI.setAIMode(newAiMode);
            
            IntegratedUIManager.elements.aiStatus.textContent = `AI: ${newAiMode ? 'ON' : 'OFF'}`;
            IntegratedUIManager.elements.aiToggle.style.background = newAiMode ? 
                'linear-gradient(135deg, var(--primary), var(--primary-dark))' :
                'linear-gradient(135deg, var(--surface-light), var(--surface-dark))';
            
            if (newAiMode) {
                IntegratedUIManager.showNotification('ü§ñ AI Mode Enabled: NPCs use smart, contextual responses');
            } else {
                IntegratedUIManager.showNotification('üìù Simple Mode: NPCs use basic, predictable responses');
            }
            
            IntegratedDialogManager.updateDialogOptions();
            
            IntegratedGameState.addComment({
                npc: IntegratedGameState.getState().currentNPC,
                text: newAiMode ? 
                    'My conversational AI just got an upgrade!' :
                    'Switching to basic response mode.',
                time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                adult: false
            });
            IntegratedUIManager.renderComments();
        });
        
        // Character interactions
        IntegratedUIManager.elements.playerCharacter.addEventListener('click', () => {
            IntegratedUIManager.addMessage('Larry: *Adjusts his tie* Looking good!', 'player');
            IntegratedGameState.addComment({
                npc: IntegratedGameState.getState().currentNPC,
                text: 'He\'s checking himself out. How vain.',
                time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                adult: false
            });
            IntegratedUIManager.renderComments();
        });
        
        IntegratedUIManager.elements.eveCharacter.addEventListener('click', () => {
            const state = IntegratedGameState.getState();
            if (state.relationship > 50) {
                if (IntegratedNPCAI.getAIMode()) {
                    IntegratedUIManager.addMessage('Eve: *smiles* Enjoying the view?', 'npc', true);
                } else {
                    IntegratedUIManager.addMessage('Eve: Hello.', 'npc');
                }
                const newMood = Math.min(100, state.mood + 5);
                IntegratedGameState.setState({ mood: newMood });
                IntegratedUIManager.updateStats();
                IntegratedQuestManager.updateQuestProgress(1, 5);
                
                // Update emotion
                EmotionSystem.influenceEmotion('Eve', 'joy', 5);
            } else {
                IntegratedUIManager.addMessage('Eve: Can I help you?', 'npc');
            }
        });
        
        // Add keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '9') {
                const index = parseInt(e.key) - 1;
                const options = document.querySelectorAll('.dialog-option:not(.disabled)');
                if (options[index]) {
                    options[index].click();
                }
            }
            
            // Space to use selected item
            if (e.key === ' ' && IntegratedGameState.getSelectedItem()) {
                IntegratedItemUseHandler.useSelectedItem();
            }
        });
        
        // Setup enhanced systems
        DateSystem.setupDateListeners();
        EndingsSystem.setupEndingsListeners();
    };
    
    return {
        init,
        startGame
    };
})();

// ===== INITIALIZE GAME =====
document.addEventListener('DOMContentLoaded', () => {
    IntegratedGameEngine.init();
});

// ===== ERROR HANDLING =====
window.addEventListener('error', (event) => {
    console.error('Game error:', event.error);
    IntegratedUIManager.showNotification('A game error occurred. Please refresh.', 'error');
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    IntegratedUIManager.showNotification('A game error occurred. Please refresh.', 'error');
});

// ===== CLEANUP ON UNLOAD =====
window.addEventListener('beforeunload', () => {
    IntegratedUIManager.cleanupEventListeners();
    clearInterval(IntegratedGameEngine.gameTimer);
    
    // Clean up all respawn timers to prevent memory leaks
    const state = IntegratedGameState.getState();
    Object.keys(state.respawnTimers).forEach(timerId => {
        clearTimeout(state.respawnTimers[timerId]);
    });
    
    // Clean up ALL timers
    const timers = window.__gameTimers || [];
    timers.forEach(timerId => {
        clearTimeout(timerId);
        clearInterval(timerId);
    });
    
    // Stop condom restock system
    IntegratedGameState.stopCondomRestockSystem();
});
</script>
</body>
</html>
